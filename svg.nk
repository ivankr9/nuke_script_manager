set cut_paste_input [stack 0]
version 9.0 v8
Group {
 inputs 0
 name SvgTools
 tile_color 0x93ff06ff
 selected true
 xpos 179
 ypos 80
 addUserKnob {20 SvgSequence}
 addUserKnob {2 SVGSeqFiles}
 addUserKnob {6 ParseFrame l "Parse One Frame to Frame 1 (No Animation)" +STARTLINE}
 addUserKnob {22 RunParse T "n = nuke.thisNode()\nc = n\['SequenceImport'].getText()\nexec(c)" +STARTLINE}
 addUserKnob {6 UseFrameByFrame l "Use Frame by Frame Animation (noMB)" -STARTLINE}
 addUserKnob {43 SequenceImport l "" +STARTLINE}
 SequenceImport "#!/usr/bin/python\nimport xml.etree.ElementTree as ET\nimport re, struct, random\nfrom os import listdir\nfrom PySide import QtGui\n# commands and values to List \ndef _tokenizeSVGCoords(pathstring):\n  commands = 'MmZzLlHhVvCcSsQqTtAa'\n  nArgsCom = '22002211116644442277'\n  commandsList = list(commands)\n  nArgsComList = list(nArgsCom)\n  commandsRe = re.compile(\"(\[\"+commands+\"])\")\n  valueRe = re.compile(\"\[-+]?\[0-9]*\\.?\[0-9]+(?:\[eE]\[-+]?\[0-9]+)?\")\n  path = \[]\n  narg = 0\n  lastcommand = ''\n  lastnargs = 0\n  comandOrValue = 0\n  ifNotFirstM = 0\n  for item in commandsRe.split(pathstring):\n    if item in \['m','M']:\n      if ifNotFirstM == 0:\n        ifNotFirstM = 1\n      else:\n        path.append('NP')\n    if item in commandsList:\n      lastnargs = nArgsComList\[commandsList.index(item)]\n      path.append(item)\n      lastcommand = item\n      comandOrValue = 0\n      narg = 0\n    for value in valueRe.findall(item):\n      path.append(float(value))\n      narg += 1\n      comandOrValue = 1\n      if narg == int(lastnargs):\n        if lastcommand == 'M':\n          lastcommand = 'L'\n        if lastcommand == 'm':\n          lastcommand = 'l'\n        path.append(lastcommand)\n        narg = 0\n    if comandOrValue == 1:\n      path.pop()\n  return path\n#Return to list path color positions closed stenciled\ndef _parseSVGPath(node,shapes,CurFrame,Palette):\n  #parse the path tokens, the arc token is not parsed, as it would take too much time to create the arc path command in nuke and it rarely used\n  #however if you want to do it feel free to write that piece of code :)\n  path = _tokenizeSVGCoords(node.attrib\['d'])\n  p0 = p1 = (0,0)\n  m0 = (0,0)\n  pos = \[]\n  ltan = \[]\n  rtan = \[]\n  sten = 0\n  numberOfM = 0\n  startPath = True\n  for i in range(len(path)):\n    if isinstance('m', basestring):\n      if path\[i] in \['M', 'm']:\n        #start a path\n        if startPath:\n          startPath = False\n          alpha = False\n        else:\n          alpha = True\n        if path\[i].istitle():\n          p0 = (path\[i+1], path\[i+2])\n          m0 = p0\n        else:\n          p0 = (p0\[0]+path\[i+1], p0\[1]+path\[i+2])\n          if numberOfM >= 1:\n            p0 = (m0\[0]+path\[i+1], m0\[1]+path\[i+2])\n          m0 = p0\n        numberOfM += 1\n        pos.append(p0)\n        ltan.append((0,0))\n        rtan.append((0,0))\n\n      elif path\[i] in \['L', 'l']:\n        if path\[i].istitle():\n          p2 = (path\[i+1], path\[i+2])\n        else:\n          p2 = (p0\[0]+path\[i+1], p0\[1]+path\[i+2])\n        pos.append(p2)\n        ltan.append((0,0))\n        rtan.append((0,0))\n        p0 = p2\n\n      elif path\[i] in \['H', 'h']:\n        if path\[i].istitle():\n          p2 = (path\[i+1], p0\[1])\n        else:\n          p2 = (p0\[0]+path\[i+1], p0\[1])\n        pos.append(p2)\n        ltan.append((0,0))\n        rtan.append((0,0))\n        p0 = p2\n\n      elif path\[i] in \['V', 'v']:\n        if path\[i].istitle():\n          p2 = (p0\[0], path\[i+1])\n        else:\n          p2 = (p0\[0], p0\[1]+path\[i+1])\n        pos.append(p2)\n        ltan.append((0,0))\n        rtan.append((0,0))\n        p0 = p2\n\n      elif path\[i] in \['C', 'c']:\n        if path\[i].istitle():\n          t1 = (path\[i+1]-p0\[0], path\[i+2]-p0\[1])\n          p2 = (path\[i+5], path\[i+6])\n          t2 = (path\[i+3]-p2\[0], path\[i+4]-p2\[1])\n        else:\n          t1 = (path\[i+1], path\[i+2])\n          p2 = (p0\[0]+path\[i+5], p0\[1]+path\[i+6])\n          t2 = (path\[i+3]-path\[i+5], path\[i+4]-path\[i+6])\n        pos.append(p2)\n        ltan.append(t2)\n        rtan\[-1] = t1\n        rtan.append((0,0))\n        p0 = p2\n\n      elif path\[i] in \['S', 's']:\n        if path\[i].istitle():\n          t1 = (-t2\[0], -t2\[1])\n          p2 = (path\[i+3], path\[i+4])\n          t2 = (path\[i+1]-p2\[0], path\[i+2]-p2\[1])\n        else:\n          t1 = (-t2\[0], -t2\[1])\n          p2 = (p0\[0]+path\[i+3], p0\[1]+path\[i+4])\n          t2 = (path\[i+1]-path\[i+3], path\[i+2]-path\[i+4])\n        pos.append(p2)\n        ltan.append(t2)\n        rtan\[-1] = t1\n        rtan.append((0,0))\n        p0 = p2\n\n      elif path\[i] in \['Q', 'q']:\n        if path\[i].istitle():\n          p1 = (path\[i+1], path\[i+2])\n          p2 = (path\[i+3], path\[i+4])\n        else:\n          p1 = (p0\[0]+path\[i+1], p0\[1]+path\[i+2])\n          p2 = (p0\[0]+path\[i+3], p0\[1]+path\[i+4])\n        \n        t1x  = p0\[0] + 0.666 *(p1\[0]-p0\[0])\n        t1y  = p0\[1] + 0.666 *(p1\[1]-p0\[1])\n        t2x  = p2\[0] + 0.666 *(p1\[0]-p2\[0])\n        t2y  = p2\[1] + 0.666 *(p1\[1]-p2\[1])\n        t1 = (t1x-p0\[0], t1y-p0\[1])\n        t2 = (t2x-p2\[0],t2y-p2\[1])\n\n        pos.append(p2)\n        ltan.append(t2)\n        rtan\[-1] = t1\n        rtan.append((0,0))\n        p0 = p2\n\n      elif path\[i] in \['T', 't']:\n      \n        if path\[i].istitle():\n          p2 = (path\[i+1], path\[i+2])\n        else:\n          p2 = (p0\[0]+path\[i+1], p0\[1]+path\[i+2])\n          \n        t1 = (-t2\[0], -t2\[1])\n        t2 = (-t2\[1], t2\[0])\n        pos.append(p2)\n        ltan.append(t2)\n        rtan\[-1] = t1\n        rtan.append((0,0))\n        p0 = p2\n      elif path\[i] in \['NP']:\n        if len(pos) != 0:\n          shapes.append(\{'path':\[pos,ltan,rtan], 'color':_getSVGNodeColor(node,Palette, CurFrame),'FL_ST_FLST':1,'stencil':1\})\n          pos = \[]\n          ltan = \[]\n          rtan = \[]\n      elif path\[i] in \['z', 'Z'] or i == len(path)-1:\n        if path\[i] in \['z','Z']:\n          ForS = 2\n        else:\n          ForS = 1\n        if numberOfM > 1:\n          sten = 1\n        shapes.append(\{'path':\[pos,ltan,rtan], 'color':_getSVGNodeColor(node,Palette, CurFrame),'FL_ST_FLST':ForS,'stencil':sten\})\n        pos = \[]\n        ltan = \[]\n        rtan = \[]\n        if i == len(path)-1:\n          break\n\n\n#convert hex color values to rgb\ndef _hex2rgb(value):\n  try:\n    value = value.lstrip('#')\n    lv = len(value)\n    if lv == 3:\n      value = ''.join(\[c*2 for c in list(value)])\n    lv = len(value)\n    val = tuple(int(value\[i:i + lv // 3], 16)/255.0 for i in range(0, lv, lv // 3))\n    srgbVal = \[]\n    for v in val:\n      if v < 0.04045:\n        v = v/12.92\n      else:\n        v = pow((v+0.055)/1.055,2.4)\n      srgbVal.append(v)\n    return tuple(srgbVal)\n  except:\n    return (1,1,1)\n\n# if Color in RGBconstuction ex: rgb(128,128,128)\ndef valInRGB(val):\n  valsplited = val.replace('(',',').replace(')',',').split(',')\n  r = float(valsplited\[1])/255\n  g = float(valsplited\[2])/255\n  b = float(valsplited\[3])/255\n  return r,g,b\n\n#get svg node color, includes a list of web colors, alpha is defined based on the subpath, subpaths will have alpha to allow for holes, however the Nuke node will just make the whole through the alpha not just through the selected shape, so it will not work exactly like in the SVG file.\ndef _getSVGNodeColor(node,Palette , Frame=0):\n  webcolors = \{'aliceblue':'#f0f8ff','antiquewhite':'#faebd7','aqua':'#00ffff','aquamarine':'#7fffd4','azure':'#f0ffff','beige':'#f5f5dc','bisque':'#ffe4c4','black':'#000000','blanchedalmond':'#ffebcd','blue':'#0000ff','blueviolet':'#8a2be2','brown':'#a52a2a','burlywood':'#deb887','cadetblue':'#5f9ea0','chartreuse':'#7fff00','chocolate':'#d2691e','coral':'#ff7f50','cornflowerblue':'#6495ed','cornsilk':'#fff8dc','crimson':'#dc143c','cyan':'#00ffff','darkblue':'#00008b','darkcyan':'#008b8b','darkgoldenrod':'#b8860b','darkgray':'#a9a9a9','darkgreen':'#006400','darkkhaki':'#bdb76b','darkmagenta':'#8b008b','darkolivegreen':'#556b2f','darkorange':'#ff8c00','darkorchid':'#9932cc','darkred':'#8b0000','darksalmon':'#e9967a','darkseagreen':'#8fbc8f','darkslateblue':'#483d8b','darkslategray':'#2f4f4f','darkturquoise':'#00ced1','darkviolet':'#9400d3','deeppink':'#ff1493','deepskyblue':'#00bfff','dimgray':'#696969','dodgerblue':'#1e90ff','firebrick':'#b22222','floralwhite':'#fffaf0','forestgreen':'#228b22','fuchsia':'#ff00ff','gainsboro':'#dcdcdc','ghostwhite':'#f8f8ff','gold':'#ffd700','goldenrod':'#daa520','gray':'#808080','green':'#008000','greenyellow':'#adff2f','honeydew':'#f0fff0','hotpink':'#ff69b4','indianred':'#cd5c5c','indigo':'#4b0082','ivory':'#fffff0','khaki':'#f0e68c','lavender':'#e6e6fa','lavenderblush':'#fff0f5','lawngreen':'#7cfc00','lemonchiffon':'#fffacd','lightblue':'#add8e6','lightcoral':'#f08080','lightcyan':'#e0ffff','lightgoldenrodyellow':'#fafad2','lightgray':'#d3d3d3','lightgreen':'#90ee90','lightpink':'#ffb6c1','lightsalmon':'#ffa07a','lightseagreen':'#20b2aa','lightskyblue':'#87cefa','lightslategray':'#778899','lightsteelblue':'#b0c4de','lightyellow':'#ffffe0','lime':'#00ff00','limegreen':'#32cd32','linen':'#faf0e6','magenta':'#ff00ff','maroon':'#800000','mediumaquamarine':'#66cdaa','mediumblue':'#0000cd','mediumorchid':'#ba55d3','mediumpurple':'#9370db','mediumseagreen':'#3cb371','mediumslateblue':'#7b68ee','mediumspringgreen':'#00fa9a','mediumturquoise':'#48d1cc','mediumvioletred':'#c71585','midnightblue':'#191970','mintcream':'#f5fffa','mistyrose':'#ffe4e1','moccasin':'#ffe4b5','navajowhite':'#ffdead','navy':'#000080','oldlace':'#fdf5e6','olive':'#808000','olivedrab':'#6b8e23','orange':'#ffa500','orangered':'#ff4500','orchid':'#da70d6','palegoldenrod':'#eee8aa','palegreen':'#98fb98','paleturquoise':'#afeeee','palevioletred':'#db7093','papayawhip':'#ffefd5','peachpuff':'#ffdab9','peru':'#cd853f','pink':'#ffc0cb','plum':'#dda0dd','powderblue':'#b0e0e6','purple':'#800080','red':'#ff0000','rosybrown':'#bc8f8f','royalblue':'#4169e1','saddlebrown':'#8b4513','salmon':'#fa8072','sandybrown':'#f4a460','seagreen':'#2e8b57','seashell':'#fff5ee','sienna':'#a0522d','silver':'#c0c0c0','skyblue':'#87ceeb','slateblue':'#6a5acd','slategray':'#708090','snow':'#fffafa','springgreen':'#00ff7f','steelblue':'#4682b4','tan':'#d2b48c','teal':'#008080','thistle':'#d8bfd8','tomato':'#ff6347','turquoise':'#40e0d0','violet':'#ee82ee','wheat':'#f5deb3','white':'#ffffff','whitesmoke':'#f5f5f5','yellow':'#ffff00','yellowgreen':'#9acd32','none':'#000000'\}\n  val = '#000000'\n  valStroke = '#000000'\n  drawStroke = 0\n  strokeWidth = '1'\n  Frameret = Frame\n  opacity = 1\n  fo = 1\n  so = 1\n  if 'style' in node.keys():\n    styles = dict(\[(style.split(':')\[0].strip(), style.split(':')\[1].strip()) for style in filter(None, node.attrib\['style'].split(';'))])\n    if 'opacity' in styles.keys():\n      opacity = styles\['opacity']\n    if 'fill' in styles.keys():\n      val = styles\['fill']\n    if 'stroke' in styles.keys():\n      drawStroke = 1\n      valStroke =  styles\['stroke']\n    if 'stroke-width' in styles.keys():\n      drawStroke = 1\n      strokeWidth = styles\['stroke-width'].replace('px','')\n    if 'fill-opacity' in styles.keys():\n      fo = styles\['fill-opacity']\n    if 'stroke-opacity' in styles.keys():\n      so = styles\['stroke-opacity']\n  else:\n    if 'fill' in node.keys():\n      val = node.attrib\['fill']\n    if 'stroke' in node.keys():\n      drawStroke = 1\n      valStroke = node.attrib\['stroke']\n    if 'opacity' in node.keys():\n      opacity = node.attrib\['opacity']\n    if 'stroke-width' in node.keys():\n      drawStroke = 1\n      strokeWidth = node.attrib\['stroke-width']\n    if 'fill-opacity' in node.keys():\n      fo = node.attrib\['fill-opacity']\n    if 'stroke-opacity' in node.keys():\n      so = node.attrib\['stroke-opacity']\n  \n  if val.lower() in webcolors.keys():\n    val = webcolors\[val.lower()]\n\n  r,g,b = _hex2rgb(val)\n  sr,sg,sb = _hex2rgb(valStroke)\n\n  if val\[0:3] == 'rgb':\n    r,g,b = valInRGB(val)\n  if valStroke\[0:3] == 'rgb':\n    sr,sg,sb = valInRGB(valStroke)\n  a = float(opacity)*float(fo)\n  sa = float(opacity)*float(so)\n\n  if val == 'none':\n    r,g,b,a = 0.0,0.0,0.0,0.0\n  if valStroke == 'none':\n    drawStroke = 0\n    sr,sg,sb,sa = 0.0,0.0,0.0,0.0\n  #rename Val to NukeParmName\n  hexFillColour = int('%02x%02x%02x%02x' % (pow(r,0.4545)*255,pow(g,0.4545)*255,pow(b,0.4545)*255,1),16)\n  val = val.replace('#','HEX').replace('(','').replace(')','').replace(',','_')+'a'+str(a)\n  valStroke = valStroke.replace('#','HEX').replace('(','').replace(')','').replace(',','_')+'a'+str(sa)\n  if Palette.get(val) == None:\n    Palette\[val] = list()\n  Palette\[val] = (r, g, b, a)\n  if Palette.get(valStroke) == None:\n    Palette\[valStroke] = list()\n  Palette\[valStroke] = (sr, sg, sb, sa)\n  return \[val, valStroke,Frameret,float(strokeWidth),drawStroke,hexFillColour]\n\n#THIS MAKE TO AUTOMATE: \ndef seqPathToTupleFiles(path):\n  pattern = '\[0-9]+'\n  found = re.findall(pattern, path)\[-1]\n  UserFile = path.replace(found, '__SEQPAD__')\n  splPath = path.split('/')\n  folder = '/'.join(splPath\[0:-1])\n  svgfiles = \[]\n  for i in listdir(folder):\n    filePath = folder + '/' + i\n    seqPadding = re.findall(pattern, filePath)\[-1]\n    osFound = filePath.replace(seqPadding,'__SEQPAD__')\n    if UserFile == osFound:\n      svgfiles.append(filePath)\n  firtframe = int(re.findall(pattern, svgfiles\[0])\[-1])\n  lastframe = int(re.findall(pattern, svgfiles\[-1])\[-1])\n  return svgfiles,firtframe,lastframe\n\n#get formatfrom SVG or Nuke Root\ndef setFormat(svg):\n  try:\n    w, h = \[int(round(float(svg.attrib\['width'].replace('px', '')))), int(round(float(svg.attrib\['height'].replace('px', ''))))]\n  except Exception, err:\n    #if that fails, try with the viewBox\n    try:\n      view = \[float(dimm) for dimm in svg.attrib\['viewBox'].replace('px', '').split(' ')]\n      w, h = \[int(round(view\[2]-view\[0])), int(round(view\[3]-view\[1]))]\n    #if that fails, put the nuke root format as format dimensions\n    except Exception, err:\n      w, h = \[nuke.Root().format().width(), nuke.Root().format().height()]\n  return w, h\n\n# Dict PathData Append List of positions from Parsing Paths \ndef FindPaths(xmlRoot, COUNTLIST , Paths, frame):\n  COUNTLIST.append('c')\n  for group in xmlRoot.getchildren():\n    if group.tag.split('\}')\[1] == 'g':\n      FindPaths(group, COUNTLIST, Paths,frame)\n      COUNTLIST.append('c')\n    if group.tag.split('\}')\[1] == 'path':\n      order = len(COUNTLIST)\n      if Paths.get(order) == None:\n        Paths\[order] = list()\n      Paths\[order].append((group,frame))\n      COUNTLIST.append('c')\n\ndef LoadSeqXML(files):\n  Paths = \{\}\n  frame = 0\n  for fl in files:\n    xml = ET.parse(fl)\n    xmlRoot = xml.getroot()\n    if frame == 0:\n      w,h = setFormat(xmlRoot)\n    COUNTLIST = \[]\n    FindPaths(xmlRoot, COUNTLIST , Paths, frame)\n    frame += 1\n  return w, h, Paths\n\n##CopyNodeFromABS toABS And return Node \ndef CopyPasteWithPath(absCopyNodePath,AbsPasteBeforePath):\n  #absCopyNodePath = 'Group1.ColorLookup1.ColorLookup1' <- Example (node.fullName())\n  nuke.root().begin()\n  listfrom = absCopyNodePath.split('.')\n  listto = AbsPasteBeforePath.split('.')\n  deep = len(listfrom)\n  i = 0\n  for grp in listfrom:\n    i += 1\n    if grp != '':\n      node = nuke.toNode(grp)\n      if deep != i:\n        node.begin()\n      else:\n        nuke.selectAll()\n        nuke.invertSelection()\n        n = nuke.toNode(grp)\n        n.setSelected(1)\n        nuke.nodeCopy('%clipboard%')\n  nuke.root().begin()\n  deep = len(listto)\n  i = 0\n  PastedNode = None\n  for grp in listto:\n    i += 1\n    if grp != '':\n      node = nuke.toNode(grp)\n      if deep != i:\n        node.begin()\n      else:\n        nuke.selectAll()\n        nuke.invertSelection()\n        n = nuke.toNode(grp)\n        PastedNode = nuke.nodePaste('%clipboard%') ## THIS PRINTED False its notGood\n        PastedNode.setXYpos(int(n\['xpos'].getValue()),int(n\['ypos'].getValue()+50))\n        PastedNode.setInput(0,n)\n  nuke.root().begin()\n  return PastedNode\n\n#set VALUE TO HEX or ADD JITTER\ndef float2Hex(val):\n  ##AddJitter\n  #r = random.random()\n  #val = val+((r-0.5)*0.1)\n  #return hex(struct.unpack('<I', struct.pack('f', val))\[0]).replace('0x','x')\n  return str(val)\n\n# send to this PATHDATA generate ANIMATE ROTO\ndef generateNukeCurves(shapeData,MakeOver,h,opened=0,animWisVisibility=0,GlobNodeName='GlobName'):\n  rotoTemplate = '''\nRoto \{\n cliptype none\n curves \{__CURVES_DATA__\}\n toolbox \{createBezier \{\n  \{ createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 \}\n  \{ createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ brush str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n\} \}\n toolbar_brush_hardness 0.200000003\n toolbar_source_transform_scale \{1 1\}\n toolbar_source_transform_center \{1050 429\}\n motionblur_mode global\n global_motionblur \{\{__GLOBNODE__.globalMotionBlur\}\}\n global_motionblur_shutter \{\{__GLOBNODE__.globalShuterAngle\}\}\n name p_\n tile_color __TILECOLOR__\n selected true\n xpos 54\n ypos 161\n\}\n'''\n  ##setup ROTO input shapeData input stencil or not\n  rootGroupTemplateBegin = '''\{\{v x3f99999a\}\n  \{f 0\}\n  \{n\n   \{layer Root\n    \{f 2097664\}\n    \{t 0 0 0 0 0 0 0 0 0\n   __SCALE__\n   __SCALE__\}\n    \{a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0\}'''\n  ## 2097152 MayeBe NumShapes\n  \n  StrokeTemplateBegin = '''\n    \{curvegroup Stroke 1049088 bezier\n     \{\{cc\n       \{f 1056768\}\n       \{px '''\n  #if opened == 1:\n  StrokeTemplateBegin = StrokeTemplateBegin.replace('1056768','1056800')\n  keyFrames = '' \n  StrokeAnimShape = ''\n  StrokeTemplateEnd = '''\n       \}\}     idem\}\n     \{tx 0 0 0\}\n     \{a r __COLOR_R__ g __COLOR_G__ b __COLOR_B__ opc __COLOR_A__ __STROKETYPE__ osw __STROKEWIDTH__ osf 0 str 1 ltn 1 ltm 1 tt x41200000\}\n    \}'''\n  FillTemplateBegin = '''\n    \{curvegroup Fill 512 bezier\n     \{\{cc\n       \{f 8192\}\n       \{px '''\n  FillAnimShape = '' \n  FillTemplateEnd = '''\n       \}\}     idem\}\n     \{tx 0 0 0\}\n     \{a r __COLOR_R__ g __COLOR_G__ b __COLOR_B__ opc __COLOR_A__ osw x41200000 osf 0 str 1 spx x44834000 spy x43d68000 sb 1 ltn 1 ltm 1 tt x40800000\}\n    \}'''\n  rootEnd = '''\n  \}\}\}'''\n  lenframe = len(shapeData)\n  openSplinePOSTemplate = '''\n          \{ \{a osw\{\{1 1\} \{x40000000\}\} osf \{\{1 0\} \{x40000000\}\}\}  __OSPLINEXY__\} '''\n  PointAnimTmp = '''\{__FRAMESPOSX__\} \{__FRAMESPOXY__\}'''\n  for framedata in shapeData:#perFrameDATA\n    keyFrames += str(framedata\['color']\[2]) + ' '# fill Kyeframes\n  listFrames = keyFrames.split(' ')\n  if animWisVisibility == 1:\n    FillAndStroke = ''\n    FillTemplateBegin += ' x41880000'\n    StrokeTemplateBegin += ' x41880000'\n    StrokeTemplateEnd = StrokeTemplateEnd.replace('__STROKETYPE__', 'osbe \{='+GlobNodeName +'.StrokeCap 1\} osee \{='+GlobNodeName +'.StrokeCap 1\}') ## \{=stroke_scale*globStrokeScale/1.9993 1\}\n    FillTemplateEnd = '''\n       \}\}     idem\}\n     \{tx 0 0 0\}\n     \{a r __COLOR_R__ g __COLOR_G__ b __COLOR_B__ opc __COLOR_A__ osw x41200000 osf 0 str 1 spx x44834000 spy x43d68000 sb 1 ltn 1 ltm 1 tt x40800000\}\n    \}'''\n    StrokeTemplateEnd = '''\n       \}\}     idem\}\n     \{tx 0 0 0\}\n     \{a r __COLOR_R__ g __COLOR_G__ b __COLOR_B__ opc __COLOR_A__ __STROKETYPE__ osw __STROKEWIDTH__ osf 0 str 1 ltn 1 ltm 1 tt x41200000\}\n    \}'''\n\n    pathNum = 0\n    for Path in shapeData:\n      FillPositions = FillTemplateBegin.replace('Fill', 'Fill_' + str(pathNum))\n      StrokePositions = StrokeTemplateBegin.replace('Stroke', 'Stroke_' + str(pathNum))\n      pt = 0\n      for point in shapeData\[pathNum]\['path']\[0]:#IteratePoints\n        FillPositions += '\\n         \{'+ str(shapeData\[pathNum]\['path']\[1]\[pt]\[0]) +' '+ str(-shapeData\[pathNum]\['path']\[1]\[pt]\[1]) +'\}' # Add First Marker\n        StrokePositions += '\\n         \{'+ str(shapeData\[pathNum]\['path']\[1]\[pt]\[0]) +' '+ str(-shapeData\[pathNum]\['path']\[1]\[pt]\[1]) +'\}' # Add First Marker To strke \n        FillPositions += '\\n         \{'+ str(shapeData\[pathNum]\['path']\[0]\[pt]\[0]) +' '+ str(h-shapeData\[pathNum]\['path']\[0]\[pt]\[1]) +'\}' # Add first Positions \n        StrokePositions += '\\n         \{\{a osw \{\{0 1\}\} osf \{\{0 0\}\}\} '+ str(shapeData\[pathNum]\['path']\[0]\[pt]\[0]) +' '+ str(h-shapeData\[pathNum]\['path']\[0]\[pt]\[1]) +'\}' # Add position to Stroke ## ADD DELOULTMARKER STROKE\n        FillPositions += '\\n         \{'+ str(shapeData\[pathNum]\['path']\[2]\[pt]\[0]) +' '+ str(-shapeData\[pathNum]\['path']\[2]\[pt]\[1]) +'\}' # add Last Marker\n        StrokePositions += '\\n         \{'+ str(shapeData\[pathNum]\['path']\[2]\[pt]\[0]) +' '+ str(-shapeData\[pathNum]\['path']\[2]\[pt]\[1]) +'\}' # add Last Marker to Stroke\n        pt += 1\n      StrokeTemplateEnd_C = StrokeTemplateEnd.replace('__STROKEWIDTH__',' \{='+str(shapeData\[pathNum]\['color']\[3])+'*'+ GlobNodeName +'.StrokeScale/1.9993 1\}')\n      StrokeTemplateEnd_C = StrokeTemplateEnd_C.replace('__STROKETYPE__', 'osbe \{='+GlobNodeName +'.StrokeCap 1\} osee \{='+GlobNodeName +'.StrokeCap 1\}') ## \{=stroke_scale*globStrokeScale/1.9993 1\}\n      FillPositions += FillTemplateEnd.replace('__COLOR_R__', '\{='+ GlobNodeName +'.'+ str(shapeData\[pathNum]\['color']\[0]) +'.r 1\}').replace('__COLOR_G__', '\{='+ GlobNodeName +'.'+ str(shapeData\[pathNum]\['color']\[0]) +'.g 1\}').replace('__COLOR_B__', '\{='+ GlobNodeName +'.'+ str(shapeData\[pathNum]\['color']\[0]) +'.b 1\}').replace('__COLOR_A__', '\{='+ GlobNodeName +'.'+ str(shapeData\[pathNum]\['color']\[0]) +'.a 1\}')\n      StrokePositions += StrokeTemplateEnd_C.replace('__COLOR_R__', '\{='+ GlobNodeName +'.'+ str(shapeData\[pathNum]\['color']\[1]) +'.r 1\}').replace('__COLOR_G__', '\{='+ GlobNodeName +'.'+ str(shapeData\[pathNum]\['color']\[1]) +'.g 1\}').replace('__COLOR_B__', '\{='+ GlobNodeName +'.'+ str(shapeData\[pathNum]\['color']\[1]) +'.b 1\}').replace('__COLOR_A__', '\{='+ GlobNodeName +'.'+ str(shapeData\[pathNum]\['color']\[1]) +'.a 1\}')\n      if shapeData\[pathNum]\['color']\[0] == 'HEX000000a1.0':\n        FillPositions = '' ## only Stroke\n      if shapeData\[pathNum]\['color']\[1] == 'HEX000000a1.0':\n        StrokePositions = ''## only Fill\n      if shapeData\[pathNum]\['FL_ST_FLST'] == 0:\n        StrokePositions = ''## only Fill\n      #if shapeData\[pathNum]\['FL_ST_FLST'] == 1:\n        #FillPositions = ''## only stroke\n      FillAndStroke = StrokePositions+FillPositions + FillAndStroke\n      pathNum +=1\n    return FillAndStroke\n  pt = 0\n\n  lenPointsinFirstFrame = len(shapeData\[0]\['path']\[0])\n  for pointPos in shapeData\[0]\['path']\[0]:#iterate Points\n    FRAMESPOSX = ''\n    FRAMESPOSY = ''\n    FRAMESTANGX = ''\n    FRAMESTANGY = ''\n    FRAMESTANG_2X = ''\n    FRAMESTANG_2Y = ''\n    AOSWAOSF = '\\n            \{  \{a osw \{__FRAMES_ONES__\} osf \{__FRAMES_ZEROS__\}'\n    FRAMES_ONES = ''\n    FRAMES_ZEROS = ''\n    STROKEPOSX = ''\n    STROKEPOSY = ''\n    for f in range(0,lenframe):\n      if len(shapeData\[f]\['path']\[0]) != lenPointsinFirstFrame:\n        raise Exception('Number Of Points in first frame and continuous is DIFFERENT\\n\\nUse Frame by Frame Animation')\n      FRAMESPOSX += '\{' + str(shapeData\[f]\['path']\[0]\[pt]\[0]) + ' -\}'\n      FRAMESPOSY += '\{' + str(h-shapeData\[f]\['path']\[0]\[pt]\[1]) + ' -\}'\n      FRAMESTANGX += '\{' + str(shapeData\[f]\['path']\[1]\[pt]\[0]) + ' -\}'\n      FRAMESTANGY += '\{' + str(-shapeData\[f]\['path']\[1]\[pt]\[1]) + ' -\}'\n      FRAMESTANG_2X += '\{' + str(shapeData\[f]\['path']\[2]\[pt]\[0]) + ' -\}'\n      FRAMESTANG_2Y += '\{' + str(-shapeData\[f]\['path']\[2]\[pt]\[1]) + ' -\}'\n      FRAMES_ONES += '\{' + listFrames\[f] + ' 1\}'\n      FRAMES_ZEROS += '\{' + listFrames\[f] + ' 0\}'\n      STROKEPOSX += '\{' + float2Hex(shapeData\[f]\['path']\[0]\[pt]\[0]) + ' -\}'\n      STROKEPOSY += '\{' + float2Hex(h-shapeData\[f]\['path']\[0]\[pt]\[1]) + ' -\}'\n    FillAnimShape += '\\n            \{  '+ PointAnimTmp.replace('__FRAMESPOSX__',FRAMESTANGX).replace('__FRAMESPOXY__',FRAMESTANGY) + '  \}'\n    FillAnimShape += '\\n            \{  '+ PointAnimTmp.replace('__FRAMESPOSX__',FRAMESPOSX).replace('__FRAMESPOXY__',FRAMESPOSY) + '  \}'\n    FillAnimShape += '\\n            \{  '+ PointAnimTmp.replace('__FRAMESPOSX__',FRAMESTANG_2X).replace('__FRAMESPOXY__',FRAMESTANG_2Y) + '  \}'\n    StrokeAnimShape += '\\n            \{'+ PointAnimTmp.replace('__FRAMESPOSX__',FRAMESTANGX).replace('__FRAMESPOXY__',FRAMESTANGY) + '  \}'\n    StrokeAnimShape += AOSWAOSF.replace('__FRAMES_ONES__', FRAMES_ONES).replace('__FRAMES_ZEROS__', FRAMES_ZEROS) + '\}\\n            \{' + STROKEPOSX + '\}\\n            \{' + STROKEPOSY + '\}  \}'\n    StrokeAnimShape += '\\n            \{'+ PointAnimTmp.replace('__FRAMESPOSX__',FRAMESTANG_2X).replace('__FRAMESPOXY__',FRAMESTANG_2Y) + '  \}'\n    pt+=1\n\n  #StrokeAnimShape = StrokeAnimShape.replace('__FIRST_MARKER__', LastMarker)\n  rootGroupTemplateBegin = rootGroupTemplateBegin.replace('__SCALE__', '\{='+ GlobNodeName + '.Scale 1\}')\n  StrokeTemplateEnd = StrokeTemplateEnd.replace('__STROKEWIDTH__',' \{='+str(shapeData\[0]\['color']\[3])+'*'+ GlobNodeName +'.StrokeScale/1.9993 1\}')\n  StrokeTemplateEnd = StrokeTemplateEnd.replace('__STROKETYPE__', 'osbe \{='+GlobNodeName +'.StrokeCap 1\} osee \{='+GlobNodeName +'.StrokeCap 1\}') ## \{=stroke_scale*globStrokeScale/1.9993 1\}\n  StrokeTemplateEnd = StrokeTemplateEnd.replace('__COLOR_R__', '\{='+ GlobNodeName +'.'+ str(shapeData\[0]\['color']\[1]) +'.r 1\}').replace('__COLOR_G__', '\{='+ GlobNodeName +'.'+ str(shapeData\[0]\['color']\[1]) +'.g 1\}').replace('__COLOR_B__', '\{='+ GlobNodeName +'.'+ str(shapeData\[0]\['color']\[1]) +'.b 1\}').replace('__COLOR_A__', '\{='+ GlobNodeName +'.'+ str(shapeData\[0]\['color']\[1]) +'.a 1\}')\n  FillTemplateEnd = FillTemplateEnd.replace('__COLOR_R__', '\{='+ GlobNodeName +'.'+ str(shapeData\[0]\['color']\[0]) +'.r 1\}').replace('__COLOR_G__', '\{='+ GlobNodeName +'.'+ str(shapeData\[0]\['color']\[0]) +'.g 1\}').replace('__COLOR_B__', '\{='+ GlobNodeName +'.'+ str(shapeData\[0]\['color']\[0]) +'.b 1\}').replace('__COLOR_A__', '\{='+ GlobNodeName +'.'+ str(shapeData\[0]\['color']\[0]) +'.a 1\}')\n  #if Anim with Visibility replace in template >> 'ltn 1 ltm 1' << to 'ltn FS ltm FE ltt 4'\n\n  keyFrames = '\{' + keyFrames + '\}'\n  \n  rotoTemplate = rotoTemplate.replace('__TILECOLOR__', str(shapeData\[0]\['color']\[5]))\n  CurveString = rootGroupTemplateBegin + StrokeTemplateBegin + keyFrames + StrokeAnimShape + StrokeTemplateEnd + FillTemplateBegin + keyFrames + FillAnimShape + FillTemplateEnd + rootEnd\n\n  # if Stroke Or Fill or Fill And Stroke\n  if shapeData\[0]\['FL_ST_FLST'] == 1:\n    CurveString = rootGroupTemplateBegin + StrokeTemplateBegin + keyFrames + StrokeAnimShape + StrokeTemplateEnd + rootEnd\n  if shapeData\[0]\['color']\[4] == 0:\n    CurveString = rootGroupTemplateBegin + FillTemplateBegin + keyFrames + FillAnimShape + FillTemplateEnd + rootEnd\n  rotoTemplate = rotoTemplate.replace('__GLOBNODE__',GlobNodeName)\n  rotoTemplate = rotoTemplate.replace('__CURVES_DATA__', CurveString )\n  return rotoTemplate\n\n# Create Pallete to CropNode \ndef CreatePalette(Palette,Node):\n    for col in Palette:\n        parm = nuke.AColor_Knob(col)\n        #parm.setDefaultValue((Palette\[col]\[0],Palette\[col]\[1],Palette\[col]\[2],Palette\[col]\[3]))\n        Node.addKnob(parm)\n        Node.knob(col).setValue(\[Palette\[col]\[0],Palette\[col]\[1],Palette\[col]\[2],Palette\[col]\[3]])\n  \nsvgtool = nuke.thisNode()\nSingleFrameEnb = svgtool\['ParseFrame'].getValue()\nFramebyFrameEnb = svgtool\['UseFrameByFrame'].getValue()\nsvgtoolABS = svgtool.fullName()\nglobNodeNoOpABS = svgtoolABS + '.Scale_ColorPalette_'\nsetResolutionCropABS = svgtoolABS + '.setResolution_'\nADJBboxABS = svgtoolABS + '.AdjBBox_'\nMBNODE = svgtoolABS + '.MotionBlur_'\nRotoNodeABS = svgtoolABS + '.p_'\nclipboard = QtGui.QApplication.clipboard()\npath = svgtool\['SVGSeqFiles'].getValue()\n## Auto Fill from OS Path Dir\nif SingleFrameEnb != 1:\n  files,fs,fe = seqPathToTupleFiles(path)\n  w,h,PathsData = LoadSeqXML(files)\nelse:\n  files = \[path,]\n  fs , fe = 1 , 1 \n  w,h,PathsData = LoadSeqXML(\[path],)\n## Create Resolution Scale Root Node And ColorPallete Node(for Append Color Parms)\nGlobNode = CopyPasteWithPath(globNodeNoOpABS,svgtoolABS)\nGlobNodeName = GlobNode.name()\nGlobNodeABS = GlobNode.fullName()\nCropNode = CopyPasteWithPath(setResolutionCropABS,GlobNodeABS)\nGlobNode\['w'].setValue(w)\nGlobNode\['h'].setValue(h)\nPalette = \{\}\nLastNodeABS = CropNode.fullName()\nif FramebyFrameEnb != 1:\n  for path in PathsData:\n    AnimShapesPath = \[]\n    for XMLNode_Frame in PathsData.get(path):\n      CurFrame = XMLNode_Frame\[1]+(fs)\n      _parseSVGPath(XMLNode_Frame\[0],AnimShapesPath,CurFrame,Palette)\n    AnimCurvesNK = generateNukeCurves(AnimShapesPath,0,h,GlobNodeName=GlobNodeName)\n    clipboard.setText(AnimCurvesNK)\n    LastROTO = nuke.nodePaste('%clipboard%')\n  ##Generate PaletteColors To CropNode add Parms from Dict palette\n  lastRotoABS = LastROTO.fullName()\n  ADJBBOXNODE = CopyPasteWithPath(ADJBboxABS,lastRotoABS)\n  ADJBBOXNODE = CopyPasteWithPath(MBNODE,ADJBBOXNODE.fullName())\n  CreatePalette(Palette,GlobNode)\n  GlobNode.setInput(0,None)\nelse:\n  rotoTemplate = '''\nRoto \{\n cliptype none\n curves \{__CURVES_DATA__\}\n toolbox \{createBezier \{\n  \{ createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 \}\n  \{ createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ brush str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n  \{ smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 \}\n\} \}\n toolbar_brush_hardness 0.200000003\n toolbar_source_transform_scale \{1 1\}\n toolbar_source_transform_center \{1050 429\}\n motionblur_mode global\n global_motionblur \{\{__GLOBNODE__.globalMotionBlur\}\}\n global_motionblur_shutter \{\{__GLOBNODE__.globalShuterAngle\}\}\n name __NAMEPASTE__\n tile_color 0x2b00ff\n selected true\n xpos 54\n ypos 161\n disable \{\{\"frame != __CURENTFRAME__\"\}\}\n\}\n'''\n  ##setup ROTO input shapeData input stencil or not\n  rootGroupTemplateBegin = '''\{\{v x3f99999a\}\n  \{f 0\}\n  \{n\n   \{layer Root\n    \{f 2097664\}\n    \{t 0 0 0 0 0 0 0 0 0\n   __SCALE__\n   __SCALE__\}\n    \{a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0\}'''\n  ## 2097152 MayeBe NumShapes\n  FrameCurves = ''\n  rotoTemplate = rotoTemplate.replace('__GLOBNODE__',GlobNodeName)\n  rootGroupTemplateBegin = rootGroupTemplateBegin.replace('__SCALE__', '\{='+ GlobNodeName + '.Scale 1\}')\n  cf = fs\n  for file in files:\n    rotoTemplateP = rotoTemplate.replace('__NAMEPASTE__', file.split('/')\[-1]+'_')\n    AnimShapesPath = \[]\n\n    AnimCurvesNK = ''\n    rotoTemplateCF = rotoTemplateP.replace('__CURENTFRAME__', str(cf))\n    w,h,PathsData = LoadSeqXML(\[file],)\n    for path in PathsData:\n      _parseSVGPath(PathsData\[path]\[0]\[0],AnimShapesPath,cf-1,Palette)\n    AnimCurvesNK = generateNukeCurves(AnimShapesPath,0,h,GlobNodeName=GlobNodeName,animWisVisibility=1) + AnimCurvesNK\n    RotoString = rotoTemplateCF.replace('__CURVES_DATA__',rootGroupTemplateBegin+AnimCurvesNK+'\}\}\}')\n    clipboard.setText(RotoString)\n    LastROTO = nuke.nodePaste('%clipboard%')\n    cf += 1\n  CreatePalette(Palette,GlobNode)\n  GlobNode.setInput(0,None)\n\n      #CurFrame = XMLNode_Frame\[1]+(fs-1)\n      #_parseSVGPath(XMLNode_Frame\[0],AnimShapesPath,CurFrame,Palette)\n    #AnimCurvesNK = generateNukeCurves(AnimShapesPath,0,h,GlobNodeName=GlobNodeName,animWisVisibility=1) + AnimCurvesNK\n\n  ##Root SCale __SCALE__ replace __GLOBNODE__ __TILECOLOR__\n  \n  #rotoTemplate = rotoTemplate.replace('__GLOBNODE__',GlobNodeName)\n  #RotoString = rotoTemplate.replace('__CURVES_DATA__',rootGroupTemplateBegin+AnimCurvesNK+'\}\}\}')\n  #\n  #\n  #\n  #\n"
 addUserKnob {20 Svg l SvgToSVGGroup(SingleFrame)}
 addUserKnob {2 svgFile}
 addUserKnob {22 CreateRotoPaths T "n = nuke.thisNode()\nc = n\['import'].getText()\nexec(c)" +STARTLINE}
 addUserKnob {43 import l "" +STARTLINE}
 import "#!/usr/bin/python\nimport xml.etree.ElementTree as ET\nimport threading, re, struct, time, random\n\n#Create the svg to roto class\nclass SvgRoto(threading.Thread):\n    def __init__(self, file, maxShapes=300, renderHidden=False):\n        threading.Thread.__init__(self)\n        #the file name\n        self.file = file\n        #list of all of the shapes\n        self.shapes = \[]\n        #maximum number of shapes\n        self.maxShapes = maxShapes\n        #render hidden SVG groups\n        self.renderHidden = renderHidden\n        #load the SVG file\n        self._loadSVG()\n        #parse the SVG file\n        self._parseSVG(self.svg)\n        self.svgtool = svgtool\n        \n    #update nuke progress and kill it if the bar is at 100%\n    def _updateProgress(self, progress, message=None):\n        if message:\n            self.progressBar.setMessage(message)\n            self.progressBar.setProgress(progress)\n        if progress == 100:\n            del(self.progressBar)\n            \n    #execute in main thread\n    def execute(self, func, *kwargs):\n        nuke.executeInMainThread(func, kwargs)\n        \n    #execute in main thread with results\n    def rexecute(self, func, *kwargs):\n        return nuke.executeInMainThreadWithResult(func, kwargs)\n     \n    #apparently not needed as Nuke seems to accept float values for vertex positions, but will keep it here just in case something changes in the future\n    def float2Hex(self,val):\n        ##AddJitter\n        #r = random.random()\n        #val = val+((r-0.5)*0.01)\n        #return hex(struct.unpack('<I', struct.pack('f', val))\[0]).replace('0x','x')\n        return str(val)\n    \n    def CopyPasteWithPath(self,absCopyNodePath,AbsPasteBeforePath):\n        #absCopyNodePath = 'Group1.ColorLookup1.ColorLookup1' <- Example (node.fullName())\n        nuke.root().begin()\n        listfrom = absCopyNodePath.split('.')\n        listto = AbsPasteBeforePath.split('.')\n        deep = len(listfrom)\n        i = 0\n        for grp in listfrom:\n            i += 1\n            if grp != '':\n                node = nuke.toNode(grp)\n                if deep != i:\n                    node.begin()\n                else:\n                    nuke.selectAll()\n                    nuke.invertSelection()\n                    n = nuke.toNode(grp)\n                    n.setSelected(1)\n                    nuke.nodeCopy('%clipboard%')\n        nuke.root().begin()\n        deep = len(listto)\n        i = 0\n        PastedNode = None\n        for grp in listto:\n            i += 1\n            if grp != '':\n                node = nuke.toNode(grp)\n                if deep != i:\n                    node.begin()\n                else:\n                    nuke.selectAll()\n                    nuke.invertSelection()\n                    n = nuke.toNode(grp)\n                    PastedNode = nuke.nodePaste('%clipboard%') ## THIS PRINTED False its notGood\n                    PastedNode.setInput(0,n)\n        nuke.root().begin()\n        return PastedNode\n\n    def setPWD(self,path):\n        nuke.root().begin()\n        listfrom = path.split('.')\n        for grp in listfrom:\n            try:\n                no = nuke.toNode(grp)\n                no.begin()\n            except: pass\n\n    def absToNode(self,absPath):\n        nuke.root().begin()\n        listfrom = absPath.split('.')\n        deep = len(listfrom)\n        i = 0\n        for grp in listfrom:\n            i += 1\n            if grp != '':\n                node = nuke.toNode(grp)\n                if deep != i:\n                    node.begin()\n                else:\n                    nuke.root().begin()\n                    return node\n\n    def convertRotoToOpenSpline(self,FillNode,StrokeNode,OpenOrClosed,MakeOver=0):\n        OutlineCurvesKnob = StrokeNode.knob('curves')\n        curvesKnob = FillNode.knob('curves')\n        Nodecontent = curvesKnob.toScript()\n        if OpenOrClosed != 1:\n            Nodecontent = Nodecontent.replace('\{f 8192\}', '\{f 1056768\}')\n        else:\n            Nodecontent = Nodecontent.replace('\{f 8192\}', '\{f 1056800\}')\n        Nodecontent = Nodecontent.replace('512 bezier', '1049088 bezier')\n        if MakeOver != 1:\n            Nodecontent = Nodecontent.replace('\{a vis 1 r \{=pow(parent.value.r,2.2) 1\} g \{=pow(parent.value.g,2.2) 1\} b \{=pow(parent.value.b,2.2) 1\} a \{=parent.value.a 1\} bm x41500000 str 1 ss 0\}\}', '\{a osbe \{=SquareStrokeBegin 1\} osee \{=SquareStrokeEnd 1\} osw \{=stroke_scale*globStrokeScale/1.9993 1\} osf 0 r \{=pow(parent.value_1.r,2.2) 1\} g \{=pow(parent.value_1.g,2.2) 1\} b \{=pow(parent.value_1.b,2.2) 1\} a \{=parent.value_1.a 1\}  str 1 tt x41200000\}\}')\n        else:\n            Nodecontent = Nodecontent.replace('\{a vis 1 r \{=pow(parent.value.r,2.2) 1\} g \{=pow(parent.value.g,2.2) 1\} b \{=pow(parent.value.b,2.2) 1\} a \{=parent.value.a 1\} str 1 ss 0\}\}', '\{a osbe \{=SquareStrokeBegin 1\} osee \{=SquareStrokeEnd 1\} osw \{=stroke_scale*globStrokeScale/1.9993 1\} osf 0 r \{=pow(parent.value_1.r,2.2) 1\} g \{=pow(parent.value_1.g,2.2) 1\} b \{=pow(parent.value_1.b,2.2) 1\} a \{=parent.value_1.a 1\}  str 1 tt x41200000\}\}')\n        Nodecontent_spl1 = Nodecontent.split('\{px x41880000')\n        MarkerPoints = Nodecontent_spl1\[1].split('\}\}     idem\}')\[0]\n        lines = MarkerPoints.replace('        ','').split('\\n')\n        ospline = ''\n        i = 0\n        first = 0\n        firstPOS = ''\n        NeedOPEN = 0\n        for mpm in lines:\n            if mpm != '':\n                if i == 0:\n                    ospline += '        ' + mpm + '\\n'\n                    i+=1\n                elif i == 1:\n                    if mpm\[1:] == firstPOS:\n                        NeedOPEN = 1\n                    ospline += '        \{\{a osw\\n'\n                    ospline += '       \{\{x41900000 1\}\}\t osf\\n'\n                    ospline += '       \{\{x41900000 0\}\}\}     ' + mpm\[1:] + '\\n'\n    \n                    if first == 0:\n                        firstPOS = mpm\[1:]\n                        first = 1\n                    i+=1\n                else:\n                    ospline += '        ' + mpm + '\\n'\n                    i=0\n            else: pass\n        if NeedOPEN == 1:\n            Nodecontent = Nodecontent.replace('\{f 1056768\}', '\{f 1056800\}')\n        Nodecontent = Nodecontent.replace(MarkerPoints , ospline)\n        OutlineCurvesKnob.fromScript(Nodecontent)\n\n    ## detect counterclocwise if notdetected return 1 if CCW return 1\n    def CWorCCW(self,tuplePositions):\n        CCW = 1\n        numpos = len(tuplePositions)\n        if numpos > 2:\n            i = 0\n            firstpos = (0,0)\n            beginAVEpos = (0,0)\n            endAVEpos = (0,0)\n            bnum = 0\n            enum = 0\n            for pos in tuplePositions:\n                if i == 0:\n                    firstpos = (pos\[0],pos\[1])\n                else:\n                    if i < numpos/2:\n                        beginAVEpos = (beginAVEpos\[0]+pos\[0],beginAVEpos\[1]+pos\[1])\n                        bnum += 1\n                    else:\n                        endAVEpos = (endAVEpos\[0]+pos\[0],endAVEpos\[1]+pos\[1])\n                        enum += 1\n                i += 1\n\n            beginAVEpos = (beginAVEpos\[0]/bnum,beginAVEpos\[1]/bnum)\n            endAVEpos = (endAVEpos\[0]/enum,endAVEpos\[1]/enum)\n            shiftPoint = ((firstpos\[0]+endAVEpos\[0])/2,(firstpos\[1]+endAVEpos\[1])/2)\n            beginAVEpos = (beginAVEpos\[0]-shiftPoint\[0],beginAVEpos\[1]-shiftPoint\[1])\n            endAVEpos = (endAVEpos\[0]-shiftPoint\[0],endAVEpos\[1]-shiftPoint\[1])\n            firstpos = (firstpos\[0]-shiftPoint\[0],firstpos\[1]-shiftPoint\[1])\n            if beginAVEpos\[0] > 0 and beginAVEpos\[1] > 0: #if ++\n                if firstpos\[0] < 0 and firstpos\[1] > 0:\n                    CCW = 0\n                if firstpos\[0] > 0 and firstpos\[1] < 0:\n                    CCW = 1\n            if beginAVEpos\[0] > 0 and beginAVEpos\[1] < 0: #if +-\n                if firstpos\[0] < 0 and firstpos\[1] < 0:\n                    CCW = 1\n                if firstpos\[0] > 0 and firstpos\[1] > 0:\n                    CCW = 0\n            if beginAVEpos\[0] < 0 and beginAVEpos\[1] < 0: #if --\n                if firstpos\[0] < 0 and firstpos\[1] > 0:\n                    CCW = 1\n                if firstpos\[0] > 0 and firstpos\[1] < 0:\n                    CCW = 0\n            if beginAVEpos\[0] < 0 and beginAVEpos\[1] > 0: #if -+\n                if firstpos\[0] > 0 and firstpos\[1] > 0:\n                    CCW = 1\n                if firstpos\[0] < 0 and firstpos\[1] < 0:\n                    CCW = 0\n        return CCW\n\n    def generateNukeCurves(self,shapeData,MakeOver,h):\n        ##setup ROTO input shapeData input stencil or not\n        shapePoints = ''\n        fshapePoints = ''\n        shapeStrings = ''\n        curvesStringTemplate = 'AddMode 0 0 0 0 \{\{v x3f99999a\}\\n  \{f 512\}\\n  \{n\\n   \{layer Root\\n    \{f 0\}\\n        \{t 0 0 0 0 0 0 0 0 0 \{=globVectorQuality 1\} \{=globVectorQuality 1\}\}\\n    \{a\}\\n    SHAPE_STRINGS\}\}\}'\n        if MakeOver != 1:\n            shapeStringTemplate = '\{curvegroup SHAPE_NAME 512 bezier\\n     \{\{cc\\n       \{f 8192\}\\n       \{px x41880000SHAPE_POINTS\}\}     idem\}\\n     \{tx 0 SHAPE_POS_X SHAPE_POS_Y\}\\n     \{a vis 1 r \{=pow(parent.value.r,2.2) 1\} g \{=pow(parent.value.g,2.2) 1\} b \{=pow(parent.value.b,2.2) 1\} a \{=parent.value.a 1\} bm x41500000 str 1 ss 0\}\}'\n        else:\n            shapeStringTemplate = '\{curvegroup SHAPE_NAME 512 bezier\\n     \{\{cc\\n       \{f 8192\}\\n       \{px x41880000SHAPE_POINTS\}\}     idem\}\\n     \{tx 0 SHAPE_POS_X SHAPE_POS_Y\}\\n     \{a vis 1 r \{=pow(parent.value.r,2.2) 1\} g \{=pow(parent.value.g,2.2) 1\} b \{=pow(parent.value.b,2.2) 1\} a \{=parent.value.a 1\} str 1 ss 0\}\}'\n        shapeString = shapeStringTemplate\n        curvesString = curvesStringTemplate\n        \n        #iterate through all the positions (points and tangents) and create the shape part of the node\n        for i in range(len(shapeData\['path']\[0])):\n            shapeData\['path']\[0]\[i] = (self.float2Hex(shapeData\['path']\[0]\[i]\[0]), self.float2Hex(h-shapeData\['path']\[0]\[i]\[1]))\n            shapeData\['path']\[1]\[i] = (self.float2Hex(shapeData\['path']\[1]\[i]\[0]), self.float2Hex(-shapeData\['path']\[1]\[i]\[1]))\n            shapeData\['path']\[2]\[i] = (self.float2Hex(shapeData\['path']\[2]\[i]\[0]), self.float2Hex(-shapeData\['path']\[2]\[i]\[1]))\n            shapePoints += '\\n        \{' + shapeData\['path']\[1]\[i]\[0] +' '+ shapeData\['path']\[1]\[i]\[1] + '\}\\n        \{' + shapeData\['path']\[0]\[i]\[0] +' '+ shapeData\['path']\[0]\[i]\[1] + '\}\\n        \{' + shapeData\['path']\[2]\[i]\[0] +' '+ shapeData\['path']\[2]\[i]\[1] + '\}'\n\n        #replace all the strings (this could be replaced to use format instead of replace)\n        shapeString = shapeString.replace('SHAPE_NUM_POINTS', str(len(shapeData\['path']\[0])*3))\n        shapeString = shapeString.replace('FSHAPE_POINTS', fshapePoints)\n        shapeString = shapeString.replace('SHAPE_POINTS', shapePoints)\n        shapeString = shapeString.replace('SHAPE_NAME', 'Shape'+str(0))\n        shapeString = shapeString.replace('SHAPE_POS_X', str(0))\n        shapeString = shapeString.replace('SHAPE_POS_Y', str(0))\n        shapeStrings = shapeString + shapeStrings\n        curvesString = curvesString.replace('SHAPE_STRINGS', shapeStrings)\n        curvesString = curvesString.replace('NUM_SHAPES', str(1))\n        return curvesString\n        ## Return curvesString for use fromScript on RotoCurves Knob\n\n    def draw(self):\n        svgtool = self.svgtool\n        nuke.root().begin()\n        w,h = self._setFormat()\n\n        fnSVGTool = svgtool.fullName()\n        svgpath = fnSVGTool + '.SVG_Path'\n\n        grp = self.CopyPasteWithPath(fnSVGTool+'.SVGGroup',fnSVGTool)\n\n        grp.setInput(0,None)\n        r = grp.knob('Resolution')\n        r.setValue((w,h))\n        grpFP = grp.fullName()\n        inp1 = grpFP+ '.Input1'\n        gTrans = grpFP+ '.GlobalTransform'\n        ColorBackground = grpFP + '.ColorBackground'\n        ColorBackgroundNode = self.absToNode(ColorBackground)\n        Output = self.absToNode(grpFP + '.Output1')\n        toMergeList = \[]\n        toMergeList.append(ColorBackgroundNode)\n        x = 0\n        y = 100\n        i = 1\n        self._updateProgress(50, 'Create Shapes')\n        lastFillRotoPATHorStencil = ''\n\n        for shapeData in self.shapes:\n            if shapeData\['stencil'] == 0:\n                svgPath = self.CopyPasteWithPath(svgpath,inp1)\n                svgPath.setInput(0,None)\n                svgPath\['label'].setValue(shapeData\['color']\[8])\n                x += 150\n                svgPath.setXYpos(x,y)\n                CCW = self.CWorCCW(shapeData\['path']\[0])\n                svgPath\['CCW'].setValue(CCW)\n                rotoFillpath = svgPath.fullName() + '.Fill'\n                rotoOutlinepath = svgPath.fullName() + '.Outline'\n                rotoFill = self.absToNode(rotoFillpath)\n                rotoOutline = self.absToNode(rotoOutlinepath)\n                rotoFillCurves = rotoFill\['curves']\n                stencil = 0\n                lastFillRotoPATHorStencil = rotoFill.fullName()\n            else:\n                ##AddStencil\n                FillNode = self.absToNode(lastFillRotoPATHorStencil)\n                self.setPWD(lastFillRotoPATHorStencil)\n                nuke.selectAll()\n                nuke.invertSelection()\n                FillNode.setSelected(1)\n                stenNode = nuke.createNode('Roto')\n                stenNode\['output'].setValue('rgba')\n                stenOutlineNode = nuke.createNode('Roto')\n                stenOutlineNode\['output'].setValue('rgba')\n                stenCurves = stenNode\['curves']\n                stenNode.setName('StencilorFill_')\n                stenOutlineNode.setName('StencilOutline_')\n                stenOutlineNode\['disable'].setExpression('which == 0')\n                lastFillRotoPATHorStencil = stenNode.fullName()\n                CCW = self.CWorCCW(shapeData\['path']\[0])\n                svgpathABS = '.'.join(lastFillRotoPATHorStencil.split('.')\[:-1])\n                svgpathNode = self.absToNode(svgpathABS)\n                MakeOver = 0\n                if svgpathNode\['CCW'].getValue() == CCW:\n                    MakeOver = 1\n                curvesString = self.generateNukeCurves(shapeData,MakeOver,h)\n                stenCurves.fromScript(curvesString)\n                closeOpen = shapeData\['FL_ST_FLST']\n                self.convertRotoToOpenSpline(stenNode, stenOutlineNode, closeOpen, MakeOver)\n                continue\n            \n            ##generate Curve for Path\n            curvesString = self.generateNukeCurves(shapeData,stencil,h)\n            \n            ##setup to ROTO\n            rotoFillCurves.fromScript(curvesString)\n\n            ##setupPath\n            closeOpen = shapeData\['FL_ST_FLST']\n            self.convertRotoToOpenSpline(rotoFill, rotoOutline, closeOpen)\n            svgPath\['which'].setValue(closeOpen)\n            ##filColor set\n            svgPath\['value'].setValue((shapeData\['color']\[0],shapeData\['color']\[1],shapeData\['color']\[2],shapeData\['color']\[3]))\n            svgPath\['value_1'].setValue((shapeData\['color']\[4],shapeData\['color']\[5],shapeData\['color']\[6],shapeData\['color']\[7]))\n            svgPath\['stroke_scale'].setValue(shapeData\['color']\[9])\n            if shapeData\['color']\[10] == 0:\n                svgPath\['which'].setValue(0)\n            TransformNode = self.absToNode(gTrans)\n            grp.begin()\n            nuke.selectAll()\n            nuke.invertSelection()\n            tclone = nuke.clone(TransformNode)\n            tclone.setInput(0,svgPath)\n            tclone.setXpos( svgPath.xpos() )\n            toMergeList.append(tclone)\n        self._updateProgress(99, 'Merge Shapes')\n        self.setPWD(grpFP)\n        nuke.selectAll()\n        nuke.invertSelection()    \n        for merges in toMergeList:\n            merges.setSelected(1)\n        M = nuke.createNode('Merge2')\n        M\['operation'].setValue('matte')\n        Output.setInput(0,M)\n        M.setXYpos(Output.xpos(),Output.ypos()-50)\n\n\n    #draw the vector shapes  ## ------------------------------------------------------OLD_DRAW_metod\n    def draw_old(self):\n        #width and height of the SVG canvas\n        w,h = self._setFormat()\n        r = self.svgtool.knob('Resolution')\n        r.setValue((w,h))\n        \n        #create the RotoPaint node Dont CreateROTO\n        self._createRotoNode()\n        \n        #strings containing parts of the nodes for version 6 and for version 7 and above\n        if nuke.NUKE_VERSION_MAJOR > 6:\n            curvesStringTemplate = 'AddMode 0 0 0 0 \{\{v x3f99999a\}\\n  \{f 0\}\\n  \{n\\n   \{layer Root\\n    \{f 0\}\\n    \{t ROOT_POS_X ROOT_POS_Y\}\\n    \{a\}\\n    SHAPE_STRINGS\}\}\}'\n            shapeStringTemplate = '\{curvegroup SHAPE_NAME 512 bezier\\n     \{\{cc\\n       \{f 8192\}\\n       \{px x41880000\\nSHAPE_POINTS\}\}     idem\}\\n     \{tx 0 SHAPE_POS_X SHAPE_POS_Y\}\\n     \{a vis 1 r RED g GREEN b BLUE a ALPHA str 1 ss 0\}\}'\n        else:\n            curvesStringTemplate = 'AddMode 0 1 0 7 Bezier1 AnimTree: \"\" \{\\n Version: 1.2\\n Flag: 0\\n RootNode: 1\\n Node: \{\\n  NodeName: \"Root\" \{\\n   Flag: 512\\n   NodeType: 1\\n   Transform: 0 0 S 0 0 S 0 0 S 0 0 S 0 1 S 0 1 S 0 0 S 0 ROOT_POS_X S 0 ROOT_POS_Y \\n   NumOfAttributes: 11\\n   \"vis\" S 0 1 \"opc\" S 0 1 \"mbo\" S 0 1 \"mb\" S 0 1 \"mbs\" S 0 0.5 \"fo\" S 0 1 \"fx\" S 0 0 \"fy\" S 0 0 \"ff\" S 0 1 \"ft\" S 0 0 \"pt\" S 0 0 \\n  \}\\n  NumOfChildren: NUM_SHAPES\\n  SHAPE_STRINGS\\n \}\\n\}'\n\n            shapeStringTemplate = 'Node: \{\\n   NodeName: \"SHAPE_NAME\" \{\\n    Flag: 576\\n    NodeType: 3\\n    CurveGroup: \"\" \{\\n     Transform: 0 0 S 1 1 0 S 1 1 0 S 1 1 0 S 1 1 1 S 1 1 1 S 1 1 0 S 1 1 SHAPE_POS_X S 1 1 SHAPE_POS_Y \\n     Flag: 0\\n     NumOfCubicCurves: 2\\n     CubicCurve: \"\" \{\\n      Type: 0 Flag: 8192 Dim: 2\\n      NumOfPoints: SHAPE_NUM_POINTS\\n      SHAPE_POINTS \\n     \}\\n     CubicCurve: \"\" \{\\n      Type: 0 Flag: 8192 Dim: 2\\n      NumOfPoints: SHAPE_NUM_POINTS\\n      FSHAPE_POINTS \\n     \}\\n     NumOfAttributes: 44\\n     \"vis\" S 0 1 \"r\" S 0 RED \"g\" S 0 GREEN \"b\" S 0 BLUE \"a\" S 0 ALPHA \"ro\" S 0 0 \"go\" S 0 0 \"bo\" S 0 0 \"ao\" S 0 0 \"opc\" S 0 1 \"bm\" S 0 0 \"inv\" S 0 0 \"mbo\" S 0 0 \"mb\" S 0 1 \"mbs\" S 0 0.5 \"mbsot\" S 0 0 \"mbso\" S 0 0 \"fo\" S 0 1 \"fx\" S 0 0 \"fy\" S 0 0 \"ff\" S 0 1 \"ft\" S 0 0 \"src\" S 0 0 \"stx\" S 0 0 \"sty\" S 0 0 \"str\" S 0 0 \"sr\" S 0 0 \"ssx\" S 0 1 \"ssy\" S 0 1 \"ss\" S 0 0 \"spx\" S 0 1024 \"spy\" S 0 778 \"stot\" S 0 0 \"sto\" S 0 0 \"sv\" S 0 0 \"sf\" S 0 1 \"sb\" S 0 1 \"nv\" S 0 1 \"view1\" S 0 1 \"ltn\" S 0 1 \"ltm\" S 0 1 \"ltt\" S 0 0 \"tt\" S 0 4 \"pt\" S 0 0 \\n    \}\\n   \}\\n   NumOfChildren: 0\\n  \}'\n        \n        shapeStrings = ''\n        curvesString = curvesStringTemplate\n        cnt=0\n        \n        #iterate through the shapes and create the node\n        #Create SVGPaths Groups and GlobTransformClones\n        for shapeData in self.shapes:\n            shapeString = shapeStringTemplate\n            shapePoints = ''\n            fshapePoints = ''\n\n            #calculate the bounding box to get the center for the pivot\n            maxX = max(t\[0] for t in shapeData\['path']\[0])\n            minX = min(t\[0] for t in shapeData\['path']\[0])\n            centerX = minX+(maxX - minX)/2\n            maxY = max(t\[1] for t in shapeData\['path']\[0])\n            minY = min(t\[1] for t in shapeData\['path']\[0])\n            centerY = h-(minY+(maxY - minY)/2)\n            \n            #iterate through all the positions (points and tangents) and create the shape part of the node\n            for i in range(len(shapeData\['path']\[0])):\n                shapeData\['path']\[0]\[i] = (self.float2Hex(shapeData\['path']\[0]\[i]\[0]), self.float2Hex(h-shapeData\['path']\[0]\[i]\[1]))\n                shapeData\['path']\[1]\[i] = (self.float2Hex(shapeData\['path']\[1]\[i]\[0]), self.float2Hex(-shapeData\['path']\[1]\[i]\[1]))\n                shapeData\['path']\[2]\[i] = (self.float2Hex(shapeData\['path']\[2]\[i]\[0]), self.float2Hex(-shapeData\['path']\[2]\[i]\[1]))\n                if nuke.NUKE_VERSION_MAJOR > 6:\n                    shapePoints += '\\n        \{' + shapeData\['path']\[1]\[i]\[0] +' '+ shapeData\['path']\[1]\[i]\[1] + '\}\\n        \{' + shapeData\['path']\[0]\[i]\[0] +' '+ shapeData\['path']\[0]\[i]\[1] + '\}\\n        \{' + shapeData\['path']\[2]\[i]\[0] +' '+ shapeData\['path']\[2]\[i]\[1] + '\}'\n                else:\n                    shapePoints += '0 S 1 1 ' + shapeData\['path']\[1]\[i]\[0] +' S 1 1 '+ shapeData\['path']\[1]\[i]\[1] + ' 0 0 S 1 1 ' + shapeData\['path']\[0]\[i]\[0] +' S 1 1 '+ shapeData\['path']\[0]\[i]\[1] + ' 0 0 S 1 1 ' + shapeData\['path']\[2]\[i]\[0] +' S 1 1 '+ shapeData\['path']\[2]\[i]\[1] + ' 0 '\n                    \n                    fshapePoints += '0 S 1 1 ' + shapeData\['path']\[1]\[i]\[0] +' S 1 1 '+ shapeData\['path']\[1]\[i]\[1] + ' 0 0 S 1 1 0 S 1 1 0 0 0 S 1 1 ' + shapeData\['path']\[2]\[i]\[0] +' S 1 1 '+ shapeData\['path']\[2]\[i]\[1] + ' 0 '\n\n            #replace all the strings (this could be replaced to use format instead of replace)\n            shapeString = shapeString.replace('SHAPE_NUM_POINTS', str(len(shapeData\['path']\[0])*3))\n            shapeString = shapeString.replace('FSHAPE_POINTS', fshapePoints)\n            shapeString = shapeString.replace('SHAPE_POINTS', shapePoints)\n            shapeString = shapeString.replace('RED', self.float2Hex(shapeData\['color']\[0]))\n            shapeString = shapeString.replace('GREEN', self.float2Hex(shapeData\['color']\[1]))\n            shapeString = shapeString.replace('BLUE', self.float2Hex(shapeData\['color']\[2]))\n            shapeString = shapeString.replace('ALPHA', self.float2Hex(shapeData\['color']\[3]))\n            shapeString = shapeString.replace('SHAPE_NAME', 'Shape'+str(cnt))\n            shapeString = shapeString.replace('SHAPE_POS_X', str(centerX))\n            shapeString = shapeString.replace('SHAPE_POS_Y', str(centerY))\n            shapeStrings = shapeString + shapeStrings\n            cnt += 1\n            \n        #replace the root node position and append the shapes\n        #set to all SVG Paths (in to For)\n        curvesString = curvesString.replace('ROOT_POS_X', str(w/2.0)).replace('ROOT_POS_Y', str(h/2.0))\n        curvesString = curvesString.replace('SHAPE_STRINGS', shapeStrings)\n        curvesString = curvesString.replace('NUM_SHAPES', str(len(self.shapes)))\n\n        #update the progress bar\n        self._updateProgress(99, 'Creating Shapes')\n        #create the node setup knob from string \n        #set in to For Nodes !!!!\n        self.curves.fromScript(curvesString)\n        \n    \n    #set the svg format (will take into account only pixel dimensions not relative ones like pt or em)\n    def _setFormat(self):\n        format = None\n        #first try finding the width/height attributes\n        try:\n            w, h = \[int(round(float(self.svg.attrib\['width'].replace('px', '')))), int(round(float(self.svg.attrib\['height'].replace('px', ''))))]\n        except Exception, err:\n            #if that fails, try with the viewBox\n            try:\n                view = \[float(dimm) for dimm in self.svg.attrib\['viewBox'].replace('px', '').split(' ')]\n                w, h = \[int(round(view\[2]-view\[0])), int(round(view\[3]-view\[1]))]\n            #if that fails, put the nuke root format as format dimensions\n            except Exception, err:\n                w, h = \[nuke.Root().format().width(), nuke.Root().format().height()]\n        #create the format if it doesn't exist\n        #for f in nuke.formats():\n        #   if f.width() == w and f.height() == h:\n        #        format = f\n        #        break\n        #if not format:\n        #    format = nuke.addFormat( str(w)+' '+str(h)+' 1.0 '+ str(w) + 'x' + str(h) )\n        #return w,h\n        return w, h\n\n    #load the SVG xml file\n    def _loadSVG(self):\n        xml = ET.parse(self.file)\n        root = xml.getroot()\n        self.xml = xml\n        self.svg = root\n        #set the svg format\n        self._setFormat()\n        \n    #create the roto node\n    def _createRotoNode(self):\n        self.node = nuke.createNode('RotoPaint')\n        self.curves = self.node\['curves']\n        #self.node\['format'].setValue(self.format)\n\n    #parse the SVG square shape\n    def _parseSVGSquare(self, node):\n        w = float(node.attrib\['width'])\n        h = float(node.attrib\['height'])\n        x = float(node.attrib\['x']) if 'x' in node.keys() else 0\n        y = float(node.attrib\['y']) if 'y' in node.keys() else x\n        rx = float(node.attrib\['rx']) if 'rx' in node.keys() else None\n        ry = float(node.attrib\['ry']) if 'ry' in node.keys() else None\n        if ry != None:\n            rx = ry\n        elif rx != None:\n            ry = rx\n        else:\n            rx = 0.0\n            ry = 0.0\n        #draw the SVG square shape\n        shape = self.squareShape(w, h, x, y, rx, ry)\n        #append results to the shapes list\n        self.shapes.append(\{'path':shape, 'color':self._getSVGNodeColor(node),'FL_ST_FLST':2,'stencil':0\})\n\n    #parse the SVG circle shape\n    def _parseSVGCircle(self, node):\n        w = float(node.attrib\['r'])\n        x = float(node.attrib\['cx']) if 'cx' in node.keys() else 0\n        y = float(node.attrib\['cy']) if 'cy' in node.keys() else x\n        #draw the SVG circle shape\n        shape = self.ellipseShape(w, w, x=x,y=y)\n        #append results to the shapes list\n        self.shapes.append(\{'path':shape, 'color':self._getSVGNodeColor(node),'FL_ST_FLST':2,'stencil':0\})\n\n    #parse the SVG ellipse shape\n    def _parseSVGEllipse(self, node):\n        w = float(node.attrib\['rx'])\n        h = float(node.attrib\['ry'])\n        x = float(node.attrib\['cx']) if 'cx' in node.keys() else 0\n        y = float(node.attrib\['cy']) if 'cy' in node.keys() else x\n        #draw the SVG ellipse shape\n        shape = self.ellipseShape(w, h, x=x,y=y)\n        #append results to the shapes list\n        self.shapes.append(\{'path':shape, 'color':self._getSVGNodeColor(node),'FL_ST_FLST':2,'stencil':0\})\n        \n    #parse the SVG polygon shape\n    def _parseSVGPolygon(self, node):\n        path = self._tokenizeSVGCoords_old(node.attrib\['points'])\n        pos = \[]\n        ltan = \[]\n        rtan = \[]\n        for i in range(len(path)):\n            if i%2 == 0:\n                pos.append((path\[i], path\[i+1]))\n                ltan.append((0,0))\n                rtan.append((0,0))\n        #append results to the shapes list\n        self.shapes.append(\{'path':\[pos, ltan, rtan], 'color':self._getSVGNodeColor(node),'FL_ST_FLST':2,'stencil':0\})\n\n    def _parseSVGLine(self, node):\n        x1 = float(node.attrib\['x1'])\n        y1 = float(node.attrib\['y1'])\n        x2 = float(node.attrib\['x2'])\n        y2 = float(node.attrib\['y2'])\n        pos = \[]\n        ltan = \[]\n        rtan = \[]\n        pos.append((x1,y1))\n        pos.append((x2,y2))\n        for i in range(0,2):\n            ltan.append((0,0))\n            rtan.append((0,0))\n        self.shapes.append(\{'path':\[pos, ltan, rtan], 'color':self._getSVGNodeColor(node),'FL_ST_FLST':1,'stencil':0\})\n        \n    #parse the path coordiantes and return a list of broken into commands and values Work_withPolYgon\n    def _tokenizeSVGCoords_old(self, pathstring):\n        commands = 'MmZzLlHhVvCcSsQqTtAa'\n        commandsList = set(commands)\n        commandsRe = re.compile(\"(\[\"+commands+\"])\")\n        valueRe = re.compile(\"\[-+]?\[0-9]*\\.?\[0-9]+(?:\[eE]\[-+]?\[0-9]+)?\")\n        path = \[]\n        for item in commandsRe.split(pathstring):\n            if item in commandsList:\n                path.append(item)\n            for value in valueRe.findall(item):\n                path.append(float(value))\n        return path\n\n    #inkscape lastcommad \n    def _tokenizeSVGCoords(self, pathstring):\n        commands = 'MmZzLlHhVvCcSsQqTtAa'\n        nArgsCom = '22002211116644442277'\n        commandsList = list(commands)\n        nArgsComList = list(nArgsCom)\n        commandsRe = re.compile(\"(\[\"+commands+\"])\")\n        valueRe = re.compile(\"\[-+]?\[0-9]*\\.?\[0-9]+(?:\[eE]\[-+]?\[0-9]+)?\")\n        path = \[]\n        narg = 0\n        lastcommand = ''\n        lastnargs = 0\n        comandOrValue = 0\n        for item in commandsRe.split(pathstring):\n            if item in commandsList:\n                lastnargs = nArgsComList\[commandsList.index(item)]\n                path.append(item)\n                lastcommand = item\n                comandOrValue = 0\n                narg = 0\n            for value in valueRe.findall(item):\n                path.append(float(value))\n                narg += 1\n                comandOrValue = 1\n                if narg == int(lastnargs):\n                    if lastcommand == 'M':\n                        lastcommand = 'L'\n                    if lastcommand == 'm':\n                        lastcommand = 'l'\n                    path.append(lastcommand)\n                    narg = 0\n            if comandOrValue == 1:\n                path.pop()\n        return path\n\n    #parse the SVG path shape\n    def _parseSVGPath(self, node):\n        #parse the path tokens, the arc token is not parsed, as it would take too much time to create the arc path command in nuke and it rarely used\n        #however if you want to do it feel free to write that piece of code :)\n        path = self._tokenizeSVGCoords(node.attrib\['d'])\n        p0 = p1 = (0,0)\n        m0 = (0,0)\n        pos = \[]\n        ltan = \[]\n        rtan = \[]\n        sten = 0\n        numberOfM = 0\n        startPath = True\n        for i in range(len(path)):\n            if isinstance('m', basestring):\n                if path\[i] in \['M', 'm']:\n                    #start a path\n                    if startPath:\n                        startPath = False\n                        alpha = False\n                    else:\n                        alpha = True\n                    if path\[i].istitle():\n                        p0 = (path\[i+1], path\[i+2])\n                        m0 = p0\n                    else:\n                        p0 = (p0\[0]+path\[i+1], p0\[1]+path\[i+2])\n                        if numberOfM >= 1:\n                            p0 = (m0\[0]+path\[i+1], m0\[1]+path\[i+2])\n                        m0 = p0\n                    numberOfM += 1\n                    pos.append(p0)\n                    ltan.append((0,0))\n                    rtan.append((0,0))\n\n                elif path\[i] in \['L', 'l']:\n                    if path\[i].istitle():\n                        p2 = (path\[i+1], path\[i+2])\n                    else:\n                        p2 = (p0\[0]+path\[i+1], p0\[1]+path\[i+2])\n                    pos.append(p2)\n                    ltan.append((0,0))\n                    rtan.append((0,0))\n                    p0 = p2\n\n                elif path\[i] in \['H', 'h']:\n                    if path\[i].istitle():\n                        p2 = (path\[i+1], p0\[1])\n                    else:\n                        p2 = (p0\[0]+path\[i+1], p0\[1])\n                    pos.append(p2)\n                    ltan.append((0,0))\n                    rtan.append((0,0))\n                    p0 = p2\n\n                elif path\[i] in \['V', 'v']:\n                    if path\[i].istitle():\n                        p2 = (p0\[0], path\[i+1])\n                    else:\n                        p2 = (p0\[0], p0\[1]+path\[i+1])\n                    pos.append(p2)\n                    ltan.append((0,0))\n                    rtan.append((0,0))\n                    p0 = p2\n\n                elif path\[i] in \['C', 'c']:\n                    if path\[i].istitle():\n                        t1 = (path\[i+1]-p0\[0], path\[i+2]-p0\[1])\n                        p2 = (path\[i+5], path\[i+6])\n                        t2 = (path\[i+3]-p2\[0], path\[i+4]-p2\[1])\n                    else:\n                        t1 = (path\[i+1], path\[i+2])\n                        p2 = (p0\[0]+path\[i+5], p0\[1]+path\[i+6])\n                        t2 = (path\[i+3]-path\[i+5], path\[i+4]-path\[i+6])\n                    pos.append(p2)\n                    ltan.append(t2)\n                    rtan\[-1] = t1\n                    rtan.append((0,0))\n                    p0 = p2\n\n                elif path\[i] in \['S', 's']:\n                    if path\[i].istitle():\n                        t1 = (-t2\[0], -t2\[1])\n                        p2 = (path\[i+3], path\[i+4])\n                        t2 = (path\[i+1]-p2\[0], path\[i+2]-p2\[1])\n                    else:\n                        t1 = (-t2\[0], -t2\[1])\n                        p2 = (p0\[0]+path\[i+3], p0\[1]+path\[i+4])\n                        t2 = (path\[i+1]-path\[i+3], path\[i+2]-path\[i+4])\n                    pos.append(p2)\n                    ltan.append(t2)\n                    rtan\[-1] = t1\n                    rtan.append((0,0))\n                    p0 = p2\n\n                elif path\[i] in \['Q', 'q']:\n                    if path\[i].istitle():\n                        p1 = (path\[i+1], path\[i+2])\n                        p2 = (path\[i+3], path\[i+4])\n                    else:\n                        p1 = (p0\[0]+path\[i+1], p0\[1]+path\[i+2])\n                        p2 = (p0\[0]+path\[i+3], p0\[1]+path\[i+4])\n                    \n                    t1x  = p0\[0] + 0.666 *(p1\[0]-p0\[0])\n                    t1y  = p0\[1] + 0.666 *(p1\[1]-p0\[1])\n                    t2x  = p2\[0] + 0.666 *(p1\[0]-p2\[0])\n                    t2y  = p2\[1] + 0.666 *(p1\[1]-p2\[1])\n                    t1 = (t1x-p0\[0], t1y-p0\[1])\n                    t2 = (t2x-p2\[0],t2y-p2\[1])\n\n                    pos.append(p2)\n                    ltan.append(t2)\n                    rtan\[-1] = t1\n                    rtan.append((0,0))\n                    p0 = p2\n\n                elif path\[i] in \['T', 't']:\n                \n                    if path\[i].istitle():\n                        p2 = (path\[i+1], path\[i+2])\n                    else:\n                        p2 = (p0\[0]+path\[i+1], p0\[1]+path\[i+2])\n                        \n                    t1 = (-t2\[0], -t2\[1])\n                    t2 = (-t2\[1], t2\[0])\n                    \n                    pos.append(p2)\n                    ltan.append(t2)\n                    rtan\[-1] = t1\n                    rtan.append((0,0))\n                    p0 = p2\n                    \n                elif path\[i] in \['z','Z'] or i == len(path)-1:\n                    if path\[i] in \['z','Z']:\n                        ForS = 2\n                    else:\n                        ForS = 1\n                    if numberOfM > 1:\n                        sten = 1\n                    self.shapes.append(\{'path':\[pos,ltan,rtan], 'color':self._getSVGNodeColor(node, alpha=alpha),'FL_ST_FLST':ForS,'stencil':sten\})\n                    pos = \[]\n                    ltan = \[]\n                    rtan = \[]\n                    if i == len(path)-1:\n                        break\n\n    #get ellipse nuke coords\n    def ellipseShape(self, w,h, x=0,y=0):\n        pos = \[(x,-h+y), (-w+x, y), (x,h+y), (w+x,y)]\n        ltan = \[(w*0.55,0), (0,-h*0.55), (-w*0.55,0), (0,h*0.55)]\n        rtan = \[(-w*0.55,0), (0,h*0.55), (w*0.55,0), (0,-h*0.55)]\n        return \[pos, ltan, rtan]\n\n    #get square nuke coords\n    def squareShape(self, w,h, x=0,y=0, xr=0,yr=0):\n        if xr !=0 and yr ==0:\n            yr = xr\n        elif xr==0 and yr != 0:\n            xr = yr\n        \n        if xr!=0 or yr!=0:\n            pos = \[(x,y+yr), (x, y+h-yr), (x+xr,y+h),(x+w-xr,y+h), (x+w,y+h-yr), (x+w, y+yr), (x+w-xr, y), (x+xr, y)]\n            ltan = \[(0, -yr/2), (0,0), (-xr/2, 0), (0,0), (0,yr/2), (0,0), (xr/2,0), (0,0)]\n            rtan = \[(0,0), (0,yr/2), (0,0), (xr/2, 0), (0,0), (0,-yr/2), (0,0), (-xr/2,0)]\n        else:\n            pos = \[(x,y), (x, y+h), (x+w,y+h), (x+w, y)]\n            ltan = \[(0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0)]\n            rtan = \[(0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0)]\n        return \[pos, ltan, rtan]\n\n    #convert hex color values to rgb\n    def _hex2rgb(self, value):\n        try:\n            value = value.lstrip('#')\n            lv = len(value)\n            if lv == 3:\n                value = ''.join(\[c*2 for c in list(value)])\n            lv = len(value)\n            return tuple(int(value\[i:i + lv // 3], 16)/255.0 for i in range(0, lv, lv // 3))\n        except:\n            return (1,1,1)\n\n    def valInRGB(self,val):\n        valsplited = val.replace('(',',').replace(')',',').split(',')\n        r = float(valsplited\[1])/255\n        g = float(valsplited\[2])/255\n        b = float(valsplited\[3])/255\n        return r,g,b\n\n    #get svg node color, includes a list of web colors, alpha is defined based on the subpath, subpaths will have alpha to allow for holes, however the Nuke node will just make the whole through the alpha not just through the selected shape, so it will not work exactly like in the SVG file.\n    def _getSVGNodeColor(self, node, alpha = False):\n        webcolors = \{'aliceblue':'#f0f8ff','antiquewhite':'#faebd7','aqua':'#00ffff','aquamarine':'#7fffd4','azure':'#f0ffff','beige':'#f5f5dc','bisque':'#ffe4c4','black':'#000000','blanchedalmond':'#ffebcd','blue':'#0000ff','blueviolet':'#8a2be2','brown':'#a52a2a','burlywood':'#deb887','cadetblue':'#5f9ea0','chartreuse':'#7fff00','chocolate':'#d2691e','coral':'#ff7f50','cornflowerblue':'#6495ed','cornsilk':'#fff8dc','crimson':'#dc143c','cyan':'#00ffff','darkblue':'#00008b','darkcyan':'#008b8b','darkgoldenrod':'#b8860b','darkgray':'#a9a9a9','darkgreen':'#006400','darkkhaki':'#bdb76b','darkmagenta':'#8b008b','darkolivegreen':'#556b2f','darkorange':'#ff8c00','darkorchid':'#9932cc','darkred':'#8b0000','darksalmon':'#e9967a','darkseagreen':'#8fbc8f','darkslateblue':'#483d8b','darkslategray':'#2f4f4f','darkturquoise':'#00ced1','darkviolet':'#9400d3','deeppink':'#ff1493','deepskyblue':'#00bfff','dimgray':'#696969','dodgerblue':'#1e90ff','firebrick':'#b22222','floralwhite':'#fffaf0','forestgreen':'#228b22','fuchsia':'#ff00ff','gainsboro':'#dcdcdc','ghostwhite':'#f8f8ff','gold':'#ffd700','goldenrod':'#daa520','gray':'#808080','green':'#008000','greenyellow':'#adff2f','honeydew':'#f0fff0','hotpink':'#ff69b4','indianred':'#cd5c5c','indigo':'#4b0082','ivory':'#fffff0','khaki':'#f0e68c','lavender':'#e6e6fa','lavenderblush':'#fff0f5','lawngreen':'#7cfc00','lemonchiffon':'#fffacd','lightblue':'#add8e6','lightcoral':'#f08080','lightcyan':'#e0ffff','lightgoldenrodyellow':'#fafad2','lightgray':'#d3d3d3','lightgreen':'#90ee90','lightpink':'#ffb6c1','lightsalmon':'#ffa07a','lightseagreen':'#20b2aa','lightskyblue':'#87cefa','lightslategray':'#778899','lightsteelblue':'#b0c4de','lightyellow':'#ffffe0','lime':'#00ff00','limegreen':'#32cd32','linen':'#faf0e6','magenta':'#ff00ff','maroon':'#800000','mediumaquamarine':'#66cdaa','mediumblue':'#0000cd','mediumorchid':'#ba55d3','mediumpurple':'#9370db','mediumseagreen':'#3cb371','mediumslateblue':'#7b68ee','mediumspringgreen':'#00fa9a','mediumturquoise':'#48d1cc','mediumvioletred':'#c71585','midnightblue':'#191970','mintcream':'#f5fffa','mistyrose':'#ffe4e1','moccasin':'#ffe4b5','navajowhite':'#ffdead','navy':'#000080','oldlace':'#fdf5e6','olive':'#808000','olivedrab':'#6b8e23','orange':'#ffa500','orangered':'#ff4500','orchid':'#da70d6','palegoldenrod':'#eee8aa','palegreen':'#98fb98','paleturquoise':'#afeeee','palevioletred':'#db7093','papayawhip':'#ffefd5','peachpuff':'#ffdab9','peru':'#cd853f','pink':'#ffc0cb','plum':'#dda0dd','powderblue':'#b0e0e6','purple':'#800080','red':'#ff0000','rosybrown':'#bc8f8f','royalblue':'#4169e1','saddlebrown':'#8b4513','salmon':'#fa8072','sandybrown':'#f4a460','seagreen':'#2e8b57','seashell':'#fff5ee','sienna':'#a0522d','silver':'#c0c0c0','skyblue':'#87ceeb','slateblue':'#6a5acd','slategray':'#708090','snow':'#fffafa','springgreen':'#00ff7f','steelblue':'#4682b4','tan':'#d2b48c','teal':'#008080','thistle':'#d8bfd8','tomato':'#ff6347','turquoise':'#40e0d0','violet':'#ee82ee','wheat':'#f5deb3','white':'#ffffff','whitesmoke':'#f5f5f5','yellow':'#ffff00','yellowgreen':'#9acd32','none':'#000000'\}\n        val = '#000000'\n        valStroke = '#000000'\n        drawStroke = 0\n        strokeWidth = '1'\n        pathID = 'shape'\n        opacity = 1\n        fo = 1\n        so = 1\n        if 'style' in node.keys():\n            styles = dict(\[(style.split(':')\[0].strip(), style.split(':')\[1].strip()) for style in filter(None, node.attrib\['style'].split(';'))])\n            if 'opacity' in styles.keys():\n                opacity = styles\['opacity']\n            if 'fill' in styles.keys():\n                val = styles\['fill']\n            if 'stroke' in styles.keys():\n                drawStroke = 1\n                valStroke =  styles\['stroke']\n            if 'stroke-width' in styles.keys():\n                drawStroke = 1\n                strokeWidth = styles\['stroke-width'].replace('px','')\n            if 'fill-opacity' in styles.keys():\n                fo = styles\['fill-opacity']\n            if 'stroke-opacity' in styles.keys():\n                so = styles\['stroke-opacity']\n        else:\n            if 'fill' in node.keys():\n                val = node.attrib\['fill']\n            if 'stroke' in node.keys():\n                drawStroke = 1\n                valStroke = node.attrib\['stroke']\n            if 'opacity' in node.keys():\n                opacity = node.attrib\['opacity']\n            if 'stroke-width' in node.keys():\n                drawStroke = 1\n                strokeWidth = node.attrib\['stroke-width']\n            if 'fill-opacity' in node.keys():\n                fo = node.attrib\['fill-opacity']\n            if 'stroke-opacity' in node.keys():\n                so = node.attrib\['stroke-opacity']\n        \n        if 'id' in node.keys():\n            pathID = node.attrib\['id']\n\n        if val.lower() in webcolors.keys():\n            val = webcolors\[val.lower()]\n        \n        r,g,b = self._hex2rgb(val)\n        sr,sg,sb = self._hex2rgb(valStroke)\n\n        if val\[0:3] == 'rgb':\n            r,g,b = self.valInRGB(val)\n        if valStroke\[0:3] == 'rgb':\n            sr,sg,sb = self.valInRGB(valStroke)\n        a = float(opacity)*float(fo)\n        sa = float(opacity)*float(so)\n\n        if val == 'none':\n            r,g,b,a = 0.0,0.0,0.0,0.0\n        if valStroke == 'none':\n            drawStroke = 0\n            sr,sg,sb,sa = 0.0,0.0,0.0,0.0\n\n        return \[r, g, b, a, sr,sg,sb,sa,pathID,float(strokeWidth),drawStroke]\n        \n    #set the color on the node\n    def setColor(self, shape, color):\n        print shape, color\n        #try:\n        #    red, green, blue, alpha = color\n        #    shape.getAttributes().set('r', red)\n        #    shape.getAttributes().set('g', green)\n        #    shape.getAttributes().set('b', blue)\n        #    shape.getAttributes().set('a', alpha)\n        #except Exception, err:\n        #    print err \n\n    #start parsing the SVG file\n    def _parseSVG(self, root):\n        empty =  '\{\{\{\{\{\{'\n        for node in root:\n            alpha = False\n            if node.tag.split('\}')\[1] == 'g':\n                if 'display' in node.keys():\n                    if not node.attrib\['display'] == 'none' or self.renderHidden:\n                        self._parseSVG(node)\n                else:\n                    self._parseSVG(node)\n            \n            elif node.tag.split('\}')\[1] == 'rect':\n                self._parseSVGSquare(node)\n                \n            elif node.tag.split('\}')\[1] == 'circle':\n                shape = self._parseSVGCircle(node)\n                \n            elif node.tag.split('\}')\[1] == 'ellipse':\n                shape = self._parseSVGEllipse(node)\n\n            elif node.tag.split('\}')\[1] == 'polygon':\n                shape = self._parseSVGPolygon(node)\n\n            elif node.tag.split('\}')\[1] == 'path':\n                shape = self._parseSVGPath(node)\n\n            elif node.tag.split('\}')\[1] == 'line':\n                shape = self._parseSVGLine(node)\n\n    #run the script in a new thread\n    def run(self):\n        self.progressBar = nuke.ProgressTask('SVG RotoPaint')\n        self._updateProgress(1, 'SVG RotoPaint - Parsing the file')\n        self.rexecute( self.draw, )\n        self._updateProgress(100, 'Finished')\nprint '!!---------------------------------------------------!!'\nfile = nuke.thisNode()\['svgFile'].getValue()\nif file:\n    svgtool = nuke.thisNode()\n    parent = nuke.toNode( '.'.join( svgtool.fullName().split('.')\[:-1] ) ) or nuke.root()\n    parent.begin()\n    SvgRoto(file,svgtool).run()"
}
 Crop {
  inputs 0
  reformat true
  crop false
  name resolution
  xpos 8
  ypos 310
 }
 ModifyMetaData {
  metadata {
   {set vectorQuality "\[value parent.VectorQuality]"}
   {set strokeWidth "\[value parent.strokeWidthScale]"}
   {set width "\[value input.width]"}
   {set height "\[value input.height]"}
  }
  name ModifyMetaData1
  xpos 8
  ypos 374
 }
 Output {
  name Output1
  xpos 8
  ypos 438
 }
 Group {
  inputs 0
  name SVG_Path
  xpos 152
  ypos 351
  postage_stamp true
  addUserKnob {20 SVGPath}
  addUserKnob {7 globVectorQuality R 0 5}
  globVectorQuality {{parent.VectorQuality}}
  addUserKnob {7 globStrokeScale}
  globStrokeScale {{parent.strokeWidthScale}}
  addUserKnob {12 Resolution}
  Resolution {{parent.Resolution.x*parent.ScaleWithResolution} {parent.Resolution.y*parent.ScaleWithResolution}}
  addUserKnob {26 ""}
  addUserKnob {3 which l Fill/Stroke/FillAndStroke}
  which 2
  addUserKnob {19 value l FillColor}
  value {0 0 0 0}
  addUserKnob {6 value_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {19 value_1 l StrokeColor}
  value_1 {0 0 0 0}
  addUserKnob {6 value_1_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {7 stroke_scale l strokeWidth_scale R 0 3}
  stroke_scale 1
  addUserKnob {6 SquareStrokeBegin +STARTLINE}
  addUserKnob {6 SquareStrokeEnd +STARTLINE}
  addUserKnob {20 SVGTransformation}
  addUserKnob {6 EnableTransform +STARTLINE}
  addUserKnob {12 m l Matrix}
  m {1 0}
  addUserKnob {12 m2 l " " -STARTLINE}
  m2 {40 530}
  addUserKnob {7 Scale}
  Scale 1
  addUserKnob {3 CCW}
 }
  Crop {
   inputs 0
   box {0 0 {Resolution.x} {Resolution.y}}
   reformat true
   crop false
   name resolution
   xpos 104
   ypos -330
  }
  Roto {
   cliptype none
   curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 512}
    {t 0 0 0 0 0 0 0 0 0
   {=globVectorQuality
    {{0 1 -}}}
   {=globVectorQuality
    {{0 1 -}}}}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}}}}}
   toolbox {createBezier {
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
   toolbar_brush_hardness 0.200000003
   toolbar_source_transform_scale {1 1}
   toolbar_source_transform_center {1050 429}
   view {}
   motionblur_on true
   name Fill
   xpos 104
   ypos -202
   disable {{"which == 1"}}
  }
  Roto {
   cliptype none
   curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 512}
    {t 0 0 0 0 0 0 0 0 0
   {=globVectorQuality
    {{0 1 -}}}
   {=globVectorQuality
    {{0 1 -}}}}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}}}}}
   toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
   toolbar_brush_hardness 0.200000003
   toolbar_source_transform_scale {1 1}
   toolbar_source_transform_center {1050 429}
   view {}
   motionblur_on true
   name Outline
   xpos 104
   ypos 374
   disable {{"which == 0"}}
  }
  Transform {
   scale {{globVectorQuality}}
   invert_matrix true
   black_outside false
   name compinsate_downsacle
   xpos 152
   ypos 438
  }
set N9461740 [stack 0]
  Transform {
   translate {{-(input.bbox.x+input.bbox.r)/2} {-(input.bbox.y+input.bbox.t)/2}}
   black_outside false
   name GetCenter_movetocenter
   xpos 248
   ypos 406
  }
  CornerPin2D {
   to1 {0 0}
   to2 {2100 0}
   to3 {2100 858}
   to4 {0 858}
   "extra matrix" 1
   transform_matrix {
       {{parent.m.x} {parent.m2.x} 0 0}
       {{parent.m.y} {parent.m2.y} 0 0}
       {0 0 1 0}
       {0 0 0 1}
     }
   invert false
   black_outside false
   from1 {0 0}
   from2 {2100 0}
   from3 {2100 858}
   from4 {0 858}
   name SetRotationSkewMatrix
   xpos 296
   ypos 438
   addUserKnob {20 User}
   addUserKnob {22 tofrom l To->From -STARTLINE T "cur=nuke.thisNode()\nto1=cur\['to1'].value()\nto2=cur\['to2'].value()\nto3=cur\['to3'].value()\nto4=cur\['to4'].value()\ncur\['from1'].setValue(to1)\ncur\['from2'].setValue(to2)\ncur\['from3'].setValue(to3)\ncur\['from4'].setValue(to4)"}
   addUserKnob {22 fromto l From->To -STARTLINE T "cur=nuke.thisNode()\nfrom1=cur\['from1'].value()\nfrom2=cur\['from2'].value()\nfrom3=cur\['from3'].value()\nfrom4=cur\['from4'].value()\ncur\['to1'].setValue(from1)\ncur\['to2'].setValue(from2)\ncur\['to3'].setValue(from3)\ncur\['to4'].setValue(from4)"}
  }
  Transform {
   translate {{parent.GetCenter_movetocenter.translate.x} {parent.GetCenter_movetocenter.translate.y}}
   invert_matrix true
   black_outside false
   name GetCenter_MoveFromCenter
   xpos 248
   ypos 470
  }
  Transform {
   center {0 {resolution.box.t}}
   black_outside false
   name setScale
   xpos 200
   ypos 534
  }
push $N9461740
  Switch {
   inputs 2
   which {{EnableTransform}}
   name UseTransformation
   label "\[value which]"
   xpos 152
   ypos 592
  }
push 0
  Switch {
   inputs 2
   which 1
   name Switch1
   label "\[value which]"
   xpos 152
   ypos 670
  }
  Output {
   name Output1
   xpos 152
   ypos 758
  }
 end_group
 Group {
  inputs 0
  name SVGGroup
  tile_color 0xa762a7ff
  xpos 296
  ypos 342
  addUserKnob {20 User l SVGGroup}
  addUserKnob {7 VectorQuality R 1 10}
  VectorQuality 1
  addUserKnob {7 strokeWidthScale R 0.01 10}
  strokeWidthScale 1
  addUserKnob {12 Resolution l "Resolution From SVG"}
  Resolution {547 450}
  addUserKnob {7 ScaleWithResolution l ScaleResolution}
  ScaleWithResolution 1
  addUserKnob {26 ""}
  addUserKnob {41 translate T GlobalTransform.translate}
  addUserKnob {41 rotate T GlobalTransform.rotate}
  addUserKnob {41 scale T GlobalTransform.scale}
  addUserKnob {41 center T GlobalTransform.center}
  addUserKnob {41 skewX l "skew X" T GlobalTransform.skewX}
  addUserKnob {41 skewY l "skew Y" T GlobalTransform.skewY}
 }
  Crop {
   inputs 0
   box {0 0 {Resolution.x*parent.ScaleWithResolution} {Resolution.y*parent.ScaleWithResolution}}
   reformat true
   crop false
   name resolution
   xpos -40
   ypos -234
  }
  NoOp {
   name Input1
   xpos -40
   ypos -106
  }
  Shuffle {
   red white
   green white
   blue white
   alpha white
   name WhiteBackground
   label "\[value in]"
   xpos -88
   ypos 232
   addUserKnob {20 Utilities}
   addUserKnob {22 shaffle_plus_channel l "                    shaffle plus channel                    " T "import node_function;nf=node_function.ShuffleNodeFunction(\"node\");nf.plus_channel()" +STARTLINE}
   addUserKnob {22 shuffle_all_color l "                   shuffle all color: RED                   " T "import node_function;nf=node_function.ShuffleNodeFunction(\"node\");nf.all_color(\"red\")" +STARTLINE}
  }
  Multiply {
   channels rgb
   name ColorBackground
   xpos -88
   ypos 278
  }
  Output {
   inputs 0
   name Output1
   xpos 104
   ypos 566
  }
  Transform {
   inputs 0
   black_outside false
   name GlobalTransform
   xpos 8
   ypos 278
  }
 end_group
 NoOp {
  inputs 0
  name Scale_ColorPalette_
  tile_color 0x281e15ff
  xpos 152
  ypos 150
  addUserKnob {20 Resolution l Scale}
  addUserKnob {7 Scale}
  Scale 1
  addUserKnob {7 StrokeScale}
  StrokeScale 1
  addUserKnob {3 w l "Width/Height From SVG"}
  w 100
  addUserKnob {3 h l "" -STARTLINE}
  h 464
  addUserKnob {7 globalMotionBlur R 0 2}
  addUserKnob {7 globalShuterAngle R 0 2}
  globalShuterAngle 0.5
  addUserKnob {6 StrokeCap l "global Stroke Cap Square" +STARTLINE}
  addUserKnob {20 ColorPalette}
 }
 Reformat {
  type "to box"
  box_width {{input.w*input.Scale}}
  box_height {{input.h*input.Scale}}
  box_fixed true
  resize none
  name setResolution_
  tile_color 0x1a211cff
  selected true
  xpos 152
  ypos 195
 }
 AdjBBox {
  inputs 0
  name AdjBBox_
  tile_color 0x1c1c1eff
  xpos 296
  ypos 182
  disable true
 }
 TimeBlur {
  shutteroffset centred
  shuttercustomoffset 0
  name MotionBlur_
  tile_color 0x332502ff
  xpos 296
  ypos 214
  disable true
 }
end_group
